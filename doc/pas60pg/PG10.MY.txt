                           Ч А С Т Ь  2.

                      СТАНДАРТНЫЕ БИБЛИОТЕКИ.

                             ГЛАВА 10.

                          МОДУЛЬ SYSTEM.

     Модуль System  является  библиотекой  Turbo   Pascal   времени
выполнения.   Он   реализует  низко-уровневые  программы  для  всех
встроенных возможностей ,  таких как ввод/вывод,  обработка  строк,
эмуляция 8087, плавающую точку, управление оверлеями и динамическое
распределение  памяти.  Модуль  System  используется  автоматически
любым модулем или программой и никогда не требуется указывать его в
утверждении uses.


                 Стандартные процедуры и функции.

     В данном  разделе  описываются  все  стандартные  процедуры  и
функции,  использующиеся в  Turbo  Pascal,  кроме  тех  процедур  и
функций ввода/вывода, которые обсуждаются в разделе "Ввод и вывод".
Более подробная информация содержится в Справочном  руководстве  по
библиотеке.
     Стандартные процедуры и  функции  являются  предопределенными.
Поскольку все предопределенные элементы действуют точно так же, как
если бы они были объявлены в окружающем  программу  блоке,  то  при
объявлении,  переопределяющем  тот  же  самый  идентификатор внутри
программы, конфликта не возникает.


                 Процедуры управления обработкой.

───────────────────────────────────────────────────────────────────
   Процедура                      Описание
───────────────────────────────────────────────────────────────────
   Exit        Позволяет немедленно выйти из текущего блока

   Halt        Останавливает выполнение программы и возвращает
               в операционную систему

   RunError    Останавливает выполнение программы и генерирует
               ошибку времени выполнения
───────────────────────────────────────────────────────────────────


              Процедуры динамического распределения.

     Эти процедуры    и   функции   используются   для   управления
кучей - областью памяти,  которая занимает  всю  свободную  память,
остающуюся  при  выполнении  программы.  Полное  описание  методов,
используемых для  управления  динамически  распределяемой  областью
памяти, приводится в разделе "Менеджер кучи" в главе 16 "Память".

───────────────────────────────────────────────────────────────────
   Процедура                      Описание
───────────────────────────────────────────────────────────────────
   Dispose     Уничтожает динамическую переменную

   FreeMem     Уничтожает динамическую переменную данного размера

   GetMem      Создает новую динамическую переменную заданного
               размера и устанавливает переменную-указатель для нее

   Mark        Записывает в переменной-указателе состояние кучи

   New         Создает новую динамическую переменную и
               устанавливает на нее переменную-указатель

   Release     Возвращает кучу в заданное состояние
───────────────────────────────────────────────────────────────────


               Функции динамического распределения.

───────────────────────────────────────────────────────────────────
     Функция                      Описание
───────────────────────────────────────────────────────────────────
   MaxAvail     Возвращает размер     наибольшего      непрерывного
                свободного   блока  кучи,  соответствующей  размеру
                наибольшей динамической переменной,  которая  может
                быть распределена в момент вызова MaxAvail

   MemAvail     Возвращает количество  имеющихся  в  куче свободных
                байт
───────────────────────────────────────────────────────────────────


                      Функции преобразования.

     Процедуры Pack и UnPack, определенные в стандартном Паскале, в
Turbo Pascal не реализованы.

───────────────────────────────────────────────────────────────────
     Функция                      Описание
───────────────────────────────────────────────────────────────────
   Chr       Возвращает символ с заданным порядковым номером

   Ord       Возвращает порядковый    номер,    имеющий    значение
             порядкового типа

   Round     Округляет значение вещественного типа до значения типа
             LongInt

   Trunc     Усекает значение  вещественного  типа до значения типа
             LongInt
───────────────────────────────────────────────────────────────────


                      Арифметические функции.

     Примечание: При компиляции в режиме числового сопроцессора, {$
N+}, возвращаемые значения в программах с плавающей точкой в модуле
System (Sqrt, Pi, Sin и т.д.) имеют тип Еxtended вместо Real.

───────────────────────────────────────────────────────────────────
     Функция                      Описание
───────────────────────────────────────────────────────────────────
   Abs         Возвращает абсолютное значение аргумента

   ArcTan      Возвращает арктангенс аргумента

   Cos         Возвращает косинус аргумента

   Exp         Возвращает экспоненту аргумента

   Frac        Возвращает дробную часть аргумента

   Int         Возвращает целую часть аргумента

   Ln          Возвращает натуральный логарифм аргумента

   Pi          Возвращает значение числа Pi
               {3.1415926535897932385}

   Sin         Возвращает синус аргумента

   Sqr         Возвращает аргумент в квадрате

   Sqrt        Возвращает квадратный корень аргумента
───────────────────────────────────────────────────────────────────


                    Процедуры порядкового типа.

───────────────────────────────────────────────────────────────────
   Процедура                      Описание
───────────────────────────────────────────────────────────────────
   Dec      Уменьшает значение переменной

   Inc      Увеличивает значение переменной
───────────────────────────────────────────────────────────────────


                     Функции порядкового типа.

───────────────────────────────────────────────────────────────────
     Функция                      Описание
───────────────────────────────────────────────────────────────────
   Odd      Проверяет, является ли аргумент нечетным числом

   Pred     Возвращает предшествующее значение аргумента

   Succ     Возвращает его последующее значение
───────────────────────────────────────────────────────────────────


                       Строковые процедуры.

───────────────────────────────────────────────────────────────────
   Процедура                      Описание
───────────────────────────────────────────────────────────────────
   Delete     Удаляет подстроку из строки

   Insert     Вставляет подстроку в строку

   Str        Преобразует численное значение в его строковое
              представление

   Val        Преобразует строковое значение в его численное
              представление
───────────────────────────────────────────────────────────────────


                        Строковые функции.

───────────────────────────────────────────────────────────────────
     Функция                      Описание
───────────────────────────────────────────────────────────────────
   Concat     Выполняет конкатенацию последовательности строк

   Copy       Возвращает подстроку из строки

   Length     Возвращает динамическую длину строки

   Pos        Производит поиск подстроки в строке
───────────────────────────────────────────────────────────────────


           Функции для работы с указателями и адресами.

───────────────────────────────────────────────────────────────────
     Функция                      Описание
───────────────────────────────────────────────────────────────────
   Addr     Возвращает адрес заданного объекта

   CSeg     Возвращает текущее значение регистра CS

   DSeg     Возвращает текущее значение регистра DS

   Ofs      Возвращает смещение заданного объекта

   Ptr      Преобразует базовый адрес сегмента и смещение  в значение
            типа указатель

   Seg      Возвращает сегмент для заданного объекта

   SPtr     Возвращает текущее значение регистра SP

   SSeg     Возвращает текущее значение регистра SS
───────────────────────────────────────────────────────────────────


                         Другие процедуры.

───────────────────────────────────────────────────────────────────
   Процедура                      Описание
───────────────────────────────────────────────────────────────────
   FillChar     Заполняет заданное число последовательных байт
                указанным значением

   Move         Копирует заданное число последовательных байт
                из источника в назначение

   Randomize    Инициализирует случайным значением встроенный
                генератор случайных чисел
───────────────────────────────────────────────────────────────────


                          Другие функции.

───────────────────────────────────────────────────────────────────
     Функция                      Описание
───────────────────────────────────────────────────────────────────
   Hi            Возвращает старший байт аргумента

   Lo            Возвращает младший байт аргумента

   ParamCount    Возвращает число параметров, переданных программе
                 в командной строке

   ParamStr      Возвращает заданный параметр командной строки

   Random        Возвращает случайное число

   SizeOf        Возвращает число байт, занимаемых аргументом

   Swap          Производит перестановку старших и младших байт
                 аргумента

   UpCase        Преобразует символ в прописной
───────────────────────────────────────────────────────────────────


                           Ввод и вывод.


     В данном  разделе  кратко описываются стандартные (встроенные)
функции и процедуры ввода-вывода Turbo Pascal.  Для более детальной
информации см. главу 19.


                      Введение во ввод/вывод.

     Файловая переменная в Паскале - это любая переменная файлового
типа.  В  Паскале  имеются  три класса файлов :  типированный файл,
текстовый файл, нетипированный файл.
     Перед использованием   файловой  переменной  она  должна  быть
связана с внешним файлом с помощью вызова процедуры Assign. Внешним
файлом  обычно  является поименнованный файл на диске,  но он также
может представлять собой устройство,  как например,  клавиатуру или
дисплей.   Во   внешних   файлах   сохраняется  записанная  в  файл
информация,  или  они  служат   источниками   информации,   которая
считывается из файла.
     Когда связь с внешним файлом установлена,  для подготовки ее к
операции   ввода   или   вывода  файловая  переменная  должна  быть
"открыта".  Существующий файл можно  открыть  с  помощью  процедуры
Reset,  а  новый  файл  можно создать и открыть с помощью процедуры
Rewrite. Текстовые  файлы,  открытые  с  помощью  процедуры  Reset,
доступны только для чтения,  а текстовые файлы,  открытые с помощью
процедуры Rewrite   и   Append,   доступны   только   для   записи.
Типированные  и  нетипированные  файлы всегда допускают как чтение,
так и запись,  независимо от  того,  были  они  открыты  с  помощью
процедуры Reset или с помощью процедуры Rewrite.
     Когда начинается выполнение  программы,  всегда  автоматически
открываются  стандартные  текстовые  файловые  переменные  Input  и
Output (ввод и вывод).  Input - это  доступный  только  для  чтения
файл,  связаный с клавиатурой,  а Output - это доступный только для
записи файл, связанный с дисплеем.
     Любой файл   представляет  собой  линейную  последовательность
элементов,  каждый из которых имеет сложный тип  (или  тип  записи)
файла.  Каждый  элемент  файла  имеет  номер.  Первый элемент файла
считается нулевым элементом.
     Обычно доступ к файлам организуется последовательно,  то есть,
когда элемент считывается с помощью стандартной процедуры  Read или
записывается с помощью стандартной процедуры Write, текущая позиция
файла перемещается к следующему по порядку элементу файла. Однако к
типированным  и  нетипированным  файлам  можно  организовать прямой
доступ с помощью стандартной  процедуры  Seek,  которая  перемещает
текущую позицию файла к заданному элементу. Текущую позицию в файле
и текущий размер  файла  можно  определить  с  помощью  стандартных
функций FilePos и FileSize.
     Когда программа   завершит   обработку   файла,   он    должен
закрываться  с  помощью стандартной процедуры Close.  После полного
закрытия файла,  связанный с ним внешний  файл  обновляется.  Затем
файловая переменная может быть связана с другим внешним файлом.
     По умолчанию,  при всех обращениях к  стандартным  функциям  и
процедурам  ввода/вывода  автоматически  производится  проверка  на
наличие ошибок.  При обнаружении ошибки программа прекращает работу
и  выводит  на  экран  сообщение  об  ошибке.  С  помощью  директив
компилятора  {$I+}  и  {$I-}  эту  автоматическую  проверку   можно
включить или выключить. Когда автоматическая проверка отключена, то
есть когда процедура или функция была скомпилирована  с  директивой
{$I-},  ошибки ввода/вывода,  возникающие при работе программы,  не
приводят  к  ее  останову.  При  этом,  чтобы  проверить  результат
выполнения  операции  ввода/вывода,  нужно использовать стандартную
функцию IOResult.


                          Процедуры В/В.

───────────────────────────────────────────────────────────────────
   Процедура                      Описание
───────────────────────────────────────────────────────────────────
   Assign       Присваивает имя внешнего файла файловой переменной

   ChDir        Меняет текущий справочник

   Close        Закрывает открытый файл

   Erase        Удаляет внешний файл

   GetDir       Возвращает текущий справочник на заданном диске

   MkDir        Создает подсправочник

   Rename       Переименовывает внешний файл

   Reset        Открывает существующий файл

   Rewrite      Создает и открывает новый файл

   RmDir        Удаляет пустой подсправочник

   Seek         Передвигает текущую позицию файла на указанную
                компоненту (не используется с текстовыми файлами).

   Truncate     Усекает размер файла до текущей позиции в файле.
                (Не используется с текстовыми файлами)
───────────────────────────────────────────────────────────────────


                           Функции В/В.

───────────────────────────────────────────────────────────────────
     Функция                      Описание
───────────────────────────────────────────────────────────────────
   Eof          Возвращает для файла состояние end-of-file (конец
                файла)

   FilePos      Возвращает текущую позицию в файле.
                (Не испольтзуется с текстовыми файлами)

   FileSize     Возвращает текущий размер файла.
                (Не испольтзуется с текстовыми файлами)

   IOResult     Возвращает целое значение, являющееся состоянием
                последней выполненной операции ввода/вывода.
───────────────────────────────────────────────────────────────────


                         Текстовые файлы.

     В этом разделе описываются операции ввода/вывода, использующие
файловую  переменную  стандартного  типа  Text.  Заметим,   что   в
Turbo Pascal тип Text отличается от типа file of char.
     При открытии текстового файла  внешний  файл  интерпретируется
особым образом:    считается,    что    он    представляет    собой
последовательность символов,  сгруппированных в строки,  где каждая
строка  заканчивается символом конца строки (end of line),  который
представляет собой символ перевода каретки,  за которым,  возможно,
следует символ перевода строки.
     Для текстовых  файлов  существует  специальный  вид   операций
чтения  и записи (Read и Write),  которые позволяют вам считывать и
записывать значения,  тип которых отличается от  типа  Char.  Такие
значения  автоматически  переводятся  в  символьное представление и
обратно. Например,  Read(F,  i),  где i - переменная  целого  типа,
приведет  к считыванию последовательности цифр,  интерпретации этой
последовательности, как десятичного числа, и сохранению его в i.
     Как было  отмечено  ранее,  имеются две стандартные переменные
текстового типа - Input и Output.  Стандартная файловая  переменная
Input  -  это  доступный  только  для  чтения  файл,  связанный  со
стандартным  файлом  ввода   операционной   системы   (обычно   это
клавиатура),   а  стандартная  файловая  переменная  Output  -  это
доступный только для записи файл,  связанный со стандартным  файлом
вывода  операционной  системы  (обычно это дисплей).  Перед началом
выполнения   программы   файлы   Input   и   Output   автоматически
открываются, как если бы были выполнены следующие операторы :

               Assign(Input,''); Reset(Input);
               Assign(Output,''); Rewrite(Output);

     Аналогично, после выполнения программы эти файлы автоматически
закрываются.

     Если программа  использует  стандартный  модуль Crt,  то файлы
Input и Output не  будут  по  умолчанию  относиться  к  стандартным
файлам  ввода/вывода.
     Для некоторых стандартных процедур,  список которых приведен в
данном  разделе,  не  требуется явно указывать в качестве параметра
файловую переменную.  Если этот параметр опущен,  то  по  умолчанию
будут рассматриваться Input и Output,  в зависимости от того, будет
ли процедура или функция ориентирована на ввод или вывод. Например,
Read(Х)   соответствует   Read(Input,Х)  и  Write(Х)  соответствует
Write(Output,Х).
     Если при вызове одной из процедур или функций из этого раздела
вы задаете файл,  этот файл должен быть связан с внешним  файлом  с
помощью  процедуры  Assign  и  открыт  с  помощью  процедуры Reset,
Rewrite,  или Append.  Если для ориентированной на вывод  процедуры
или  функции  Вы  указываете на файл,  который был открыт с помощью
процедуры Reset, то выведется сообщение об ошибке.
     Аналогично, будет ошибкой задавать для ориентированной на ввод
процедуры или функции файл, открытый с помощью процедур Rewrite или
Append .


                            Процедуры:

───────────────────────────────────────────────────────────────────
   Процедура                      Описание
───────────────────────────────────────────────────────────────────
   Append        Открывает существующий файл для добавления

   Flush         Выталкивает буфер файла вывода

   Read          Считывает одно или более значений из текстового
                 файла в одну или более переменных

   Readln        Выполняет те же действия, что и Read, а потом
                 делает пропуск до начала следующей строки файла

   SetTextBuf    Назначает буфер ввода/вывода для текстового файла

   Write         Записывает в текстовый файл одно или более
                 значений

   Writeln       Выполняет те же действия, что и Write, а затем до-
                 бавляет к файлу маркер конца строки
───────────────────────────────────────────────────────────────────


                            Функции:

───────────────────────────────────────────────────────────────────
     Функция                      Описание
───────────────────────────────────────────────────────────────────
   Eoln          Возвращает для файла состояние end-of-line (конец
                 строки)

   SeekEof       Возвращает для файла состояние end-of-file (конец
                 файла)

   SeekEoln      Возвращает для файла состояние end-of-line (конец
                 строки)
───────────────────────────────────────────────────────────────────


                       Нетипированные файлы.

     Нетипированные файлы  представляют  собой  каналы ввода/вывода
нижнего уровня,  используемые в  основном  для  прямого  доступа  к
любому файлу на диске, независимо от его типа и структуры.
     Любой нетипированный  файл  объявляется  со  словом  file  без
атрибутов, например:

               var
                  Datafile : file;

     Для нетипированных  файлов  в  процедурах  Reset   и   Rewrite
допускается указывать дополнительный параметр,  чтобы задать размер
записи, использующийся при передаче данных.
     По умолчанию  длина  записи  равна 128 байт.  Предпочтительной
длиной записи  является  длина  записи,  равная  1,  поскольку  это
единственное значение,  которое  точно отражает размер любого файла
(если длина записи равна 1, то неполные записи невозможны).
     За исключением процедур Read и Write для  всех  нетипированных
файлов   допускается  использование  любой  стандартной  процедуры,
которую разрешено  использовать  с  типированными  файлами.  Вместо
процедур  Read  и Write здесь используются соответственно процедуры
BlockRead и BlockWrite,  позволяющие пересылать  данные  с  высокой
скоростью.


                            Процедуры.

───────────────────────────────────────────────────────────────────
   Процедура                      Описание
───────────────────────────────────────────────────────────────────
   BlockRead      Считывает в переменную одну или более записей

   BlockWrite     Записывает одну или более записей из переменной
───────────────────────────────────────────────────────────────────


                       Переменная FileMode.

     Переменная FileMode,    определенная    в    модуле    System,
устанавливает код   доступа,   который   передается  в  DOS,  когда
типированные и нетипированные файлы (но не текстовые) открываются с
помощью процедуры Reset.
     По умолчанию задается  значение  FileMode  равное  2,  которое
разрешает   и  чтение,  и  запись.  Присваивание  другого  значения
переменной FileMode приводит к тому,  что  все  последующие  вызовы
процедуры Reset будут использовать этот режим.
     Диапазон возможных значений FileMode зависит  от  используемой
версии DOS. Однако для всех версий задаются следующие режимы :

     0 : только чтение
     1 : только запись
     2 : чтение/запись

     Версия 3.X  DOS задает дополнительные режимы,  которые главным
образом связаны с разделенным использованием файлов в  сетях.  (Для
получения  более  подробной  информации,  обратитесь  к руководству
программиста по DOS).

     Примечание: Новые  файлы,  созданные   с   помощью   процедуры
Rewrite,  всегда  открываются в режиме Read/Write,  соответствующем
значению переменной FileMode = 2.


                    Устройства в Turbo Pascal.

     В Turbo   Pascal   и   в   операционной  системе  DOS  внешняя
аппаратура,  как например,  клавиатура, устройство печати, дисплей,
рассматриваются,   как  устройства.  С  точки  зрения  программиста
устройство можно рассматривать как файл и с ним  можно  работать  с
помощью того же набора стандартных функций, что и с файлом. В Turbo
Pascal поддерживается  два  типа  устройств  -  устройства  DOS   и
устройства для текстовых файлов.


                          Устройства DOS.

     Устройства DOS реализованы с  помощью  зарезервированных  имен
устройств,   которые   имееют  специальный  смысл.  Устройства  DOS
полностью прозрачны  :  в  Turbo  Pascal  неизвестно  даже,   когда
файловая  переменная  связана  с  устройством,  а когда с файлом на
диске. Например, программа:

               var
                  Lst : Text;
               begin
                  Assign(Lst, 'LPT1');
                  Rewrite(Lst);
                  Writeln(Lst, 'Hello World ...');
                  Close(Lst);
               end.

     выведет строку 'Hello World ...' на  устройство  печати,  хотя
синтаксис  точно  такой  же,  как  если бы она выводилась в файл на
диске.
     Устройства, реализованные    в   операционной   системе   DOS,
используются для одновременного ввода или вывода.
     Таким образом,  устройства  в DOS используются ,  обычно,  для
вывода текстовых файлов. В редких случаях для работы с устройствами
DOS  может  оказаться  полезным использование также нетипированного
файла.  Каждое из устройств DOS описывается в следующем разделе.  В
других  реализациях  DOS  может  быть  предусмотрено  использование
дополнительных устройств,  поэтому мы не  можем  предусмотреть  все
возможные случаи для описываемых в данном руководстве устройств.


                          Устройство CON.

     Устройство CON означает консоль, посредством которой выводимая
информация  пересылается  на  экран дисплея,  а вводимая информация
воспринимается с клавиатуры.  Если  не  было  изменено  направление
ввода  или  вывода,  то  стандартные  файлы  Input  и  Output и все
файлы, которым присвоено пустое имя,  ссылаются на устройство  CON.
Вводимая с   устройства   CON   информация   является   строчно   -
ориентированной и  использует   средства   редактирования   строки,
которые описаны в руководстве по DOS. Символы считываются из буфера
строки, а когда буфер становится пустым, вводится новая строка. При
нажатии    клавиши   CTRL-Z   генерируется   символ   конца   файла
(end-of-file), после которого функция eof будет возвращать значение
True.


                   Устройства LРT1, LРT2, LРT3.

     В качестве   возможного    построчного    устройства    печати
допускается использование трех устройств печати.  Если присоединено
одно устройство печати,  на него обычно ссылаются как на устройство
LРT1. Для этого устройства можно также использовать синоним PRN.
     Построчное устройство печати - это устройство, предназначенное
только для  вывода.  При любой попытке использовать процедуру Reset
для открытия файла, связанного с одним из этих устройств, немедлен-
но генерируется признак конца файла.

     Примечание: Стандартный  модуль  Printer  описывает  текстовую
файловую переменную  с  именем  Lst  и  устанавливает  ее  связь  с
устройством  LРT1.  Чтобы обеспечить вывод какой-либо информации из
вашей программы на устройство печати, включите в предложение uses в
своей программе модуль Printer,  а для вывода используйте процедуры
Write(Lst, ...).


                     Устройства  COM1 и COM2.

     Устройствами коммуникационного      порта     являются     два
последовательных  коммуникационных   порта.   Вместо   COM1   можно
использовать синоним AUX.


                          Устройство NUL.

     Нулевое устройство  игнорирует  любую   запись   на   него   и
немедленно  генерирует признак конца файла при попытке считывания с
этого устройства.  Его следует  использовать,  если  вы  не  хотите
создавать  отдельный  файл,  а  в  программе  требуется указать имя
входного или выходного файла.


             Устройство, предназначенное для текстовых
                              файлов.

     Устройство предназначенное для текстовых  файлов, используется
для  реализации  устройств,  не  поддерживаемых DOS,  или для того,
чтобы  сделать  доступным  набор  средств,  отличающийся  от  того,
который  предусмотрен  для  аналогичного  устройства  DOS.  Хорошим
примером  устройства,  предназначенного   для   текстового   файла,
является  устройство  CRT,  реализованное  с  помощью  стандартного
модуля Crt. Его основной функцией является обеспечение интерфейса с
дисплеем  и  клавиатурой,  аналогично устройству CON в DOS.  Однако
устройство  CRT  является  более  быстрым  и   поддерживает   такие
неоценимые   средства,  как  использование  цветов  и  окон.
     В отличие от устройств DOS,  устройства,  предназначенные  для
вывода   текстовых   файлов,   не   имеют  зарезервированных  имен.
Фактически у них вообще отсутствуют имена.
     Вместо этого  файл связывается с устройством с помощью обычной
процедуры  Assign.  Например,  стандартный  модуль  Crt   реализует
процедуру   AssignCrt,   которая   связывает   текстовые   файлы  с
устройством CRT.
     Кроме устройства   CRT,   в   Turbo   Pascal   для  устройств,
предназначенных  для  текстовых  файлов,  Вы  можете  писать   свои
собственные  драйверы.  Полностью  этот вопрос освещается в разделе
"Драйвер устройства текстового файла" в главе 19 "Ввод и вывод".


                   Предопределенные переменные.

     Кроме процедур  и  функций  модуль  System  обеспечивает   ряд
предопределенных переменных.


                 Неинициализированные переменные.

───────────────────────────────────────────────────────────────────
     Переменная   Тип            Описание
───────────────────────────────────────────────────────────────────
     Input        Text        стандартный файл ввода
     Output       Text        стандартный файл вывода
     SaveInt00    Pointer     сохранение прерывания $00
     SaveInt02    Pointer     сохранение прерывания $02
     SaveInt1B    Pointer     сохранение прерывания $1B
     SaveInt21    Pointer     сохранение прерывания $21
     SaveInt23    Pointer     сохранение прерывания $23
     SaveInt24    Pointer     сохранение прерывания $24
     SaveInt35    Pointer     сохранение прерывания $35
     SaveInt36    Pointer     сохранение прерывания $36
     SaveInt37    Pointer     сохранение прерывания $37
     SaveInt38    Pointer     сохранение прерывания $38
     SaveInt39    Pointer     сохранение прерывания $39
     SaveInt3A    Pointer     сохранение прерывания $3A
     SaveInt3B    Pointer     сохранение прерывания $3B
     SaveInt3C    Pointer     сохранение прерывания $3C
     SaveInt3D    Pointer     сохранение прерывания $3D
     SaveInt3F    Pointer     сохранение прерывания $3F
     SaveInt3E    Pointer     сохранение прерывания $3E
     SaveInt75    Pointer     сохранение прерывания $75
───────────────────────────────────────────────────────────────────


                  Инициализированные переменные.

───────────────────────────────────────────────────────────────────
Переменная    Тип     Начальное       Описание
                      значение
───────────────────────────────────────────────────────────────────
OvrCodeList   Word       0       список оверлейных сегментов кода

OvrHeapSize   Word       0       начальный размер буфера оверлеев

OvrDebugPtr   Pointer    nil     вектор отладчика оверлеев

OvrHeapOrg    Word       0       начало буфера оверлеев

OvrHeapPrt    Word       0       указатель буфера оверлеев

OvrHeapEnd    Word       0       конец буфера оверлеев

OvrLoadList   Word       0       список загруженных оверлеев

OvrDosHandle  Word       0       обработчик DOS оверлеев

OvrEmsHandle  Word       0       обработчик EMS оверлеев

HeapOrg       Pointer    nil     начало  кучи

HeapPtr       Pointer    nil     указатель  кучи

HeapEnd       Pointer    nil     конец кучи

FreeList      Pointer    nil     список свободных блоков кучи

HeapError     Pointer    nil     функция обработки ошибок кучи

ExitProc      Pointer    nil     процедура выхода

ExitCode      Integer    0       выходной код

ErrorAddr     Pointer    nil     адрес ошибки времени выполнения

PrefixSeg     Word       0       префикс программного сегмента

StackLimit    Word       0       указатель на нижнюю границу стека

InOutRes      Integer    0       буфер результата в/в

RandSeed      LongInt    0       опорное значение генератора
                                 случайных чисел

FileMode      Byte       2       режим открытия файла

Test8087      Byte       0       результат теста 8087
───────────────────────────────────────────────────────────────────

     OvrCodeList, OvrHeapSize, OvrDebugPtr, OvrHeapOrg, OvrHeapPtr,
OvrHeapEnd, OvrHeapList,  OvrDosHandle и OvrEmsHandle  используются
модулем  Overlay  для  реализации  менеджера оверлеев Turbo Pascal.
Буфер оверлеев  размещается  между  сегментом  стека  и   кучей   и
OvrHeapOrg  и  OvrHeapEnd  содержат адреса начала и конца сегмента.
Размер  буфера  оверлеев   по   умолчанию   соответствует   размеру
максимального оверлея  в программе;  если в программе нет оверлеев,
то размер оверлейного буфера равен  нулю.  Размер  буфера  оверлеев
может  быть  увеличен  через  вызов  процедуры  OvrSetBuf из модуля
Overlay, в этом  случае  размер  кучи  соответственно  уменьшается,
увеличивая значение HeapOrg.
     HeapOrg, HeapPtr,  HeapEnd,  FreeList,  HeapError используются
монитором кучи  для  реализации программ распределения динамической
памяти Turbo Pascal.  Монитор кучи  полностью  описан  в  главе  16
"Память".
     Переменные ExitProc,  ExitCode и ErrorAddr реализуют процедуры
выхода. Они так же описаны в главе 18 "Вопросы контроля".
     PrefixSeg - это переменная типа слово (Word), содержащая адрес
сегмента префикса сегмента программы (PSP),  создаваемый DOS, когда
программа выполняется.  Полное описание префикса сегмента программы
смотрите в руководстве по операционной системе.
     StackLimit содержит смещение от нижней границы сегмента стека,
соответствующее  наименьшему  значению  регистра  SP допустимому до
того, пока стек не будет переполнен.  Обычно StackLimit равен нулю,
но, если программа откомпилирована с опциями {$N+,E+} эмулятор 8087
будет  устанавливать  его  равным  224  для резервирования рабочего
пространства на нижней границе сегмента  стека,  если  8087  нет  в
системе.
     InOutRes используется встроенными программами ввода/вывода для
запоминания   значения   возвращаемого   при   последующем   вызове
стандартной функции IOResult.
     RandSeed содержит опорное число  генератора  случайных  чисел.
При присваивании необходимого значения переменной RandSeed, функция
Random будет генерировать определенную последовательность случайных
чисел  снова  и  снова.  Это полезно в приложениях,  где необходимо
шифрование данных, в статистике и симулировании.
     FileMode позволяет  Вам  изменить  режим  доступа,  с  которым
открываются типированные  и  нетипированные   файлы.   (Стандартной
процедурой Reset).  Для  больших  деталей смотри раздел "Переменная
FileMode".
     Test8087 хранит  результат теста автообнаружения сопроцессора,
который выполняется  при  запуске  программы,  откомпилированной  с
{$N+}. Для больших деталей смотри главу 14 "Использование 8087".
     Input и Output - стандартные  файлы  ,  необходимые  в  каждой
реализации языка Паскаль. По умолчанию они ссылаются на стандартные
входные и выходные файлы в DOS.  Для больших деталей смотри  раздел
"Ввод/вывод".
     Модуль System устанавливает некоторые вектора  прерывания.  До
установки собственных   программ   обработки   прерываний,   System
запоминает старые вектора в переменных SaveIntXX.
     Заметим, что  модуль System содержит обработчик прерывания INT
24 для перехвата критических ошибок.
     В программах   Turbo   Pascal   критические   ошибки   в   DOS
обрабатываются как любые другие ошибки ввода/вывода; в состоянии {$
I+} программа   завершается  с  ошибкой  времени  выполнения,  а  в
состоянии {$I-} IOResult возвращает ненулевое значение.
     Здесь приводится     основа    программы,    восстанавливающей
первоначальный  вектор  и,  следовательно,  первоначальную   логику
обработки критических ситуаций.

     programm Restore;
     uses Dos;
     begin
        SetIntVeg ($24, SaveInt 24);
        ........
     end.

     Процедура SwapVectors в  модуле  Dos  переставляет  содержимое
переменных  SaveIntXX  с  текущим  содержимым  векторов прерывания.
SwapVectors   должна   быть   вызвана   непосредственно   перед   и
непосредственно после  вызова  процедуры Exec,  для того чтобы быть
уверенным что запускаемый через Exec процесс не использует  какой -
либо  обработчик  прерывания,  установленный  в  текущем процессе и
наоборот.  Для  большей  информации   смотри   описание   процедуры
SwapVectors в Справочном руководстве по библиотеке.

