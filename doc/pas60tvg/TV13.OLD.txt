                             ГЛАВА 13.

                      СПРАВОЧНИК ПО ОБЪЕКТАМ.

     Эта глава содержит алфавитный список всех стандартных объектов
Turbo Vision с объяснением их назначения и использования, с полями,
методами и палитрами цветов.
     Чтобы найти  информацию по определенному объекту помните,  что
многие свойства объектов в иерархии наследуются от  предков. Вместо
бесконечного дублирования   всей  информации  эта  глава  описывает
только поля и методы,  которые добавляются или  изменяются  в  этом
объекте.
     Например, если Вы хотите найти поле Owner объекта  TLabel,  Вы
можете посмотреть  поля TLabel,  среди которых Вы не найдете Owner.
Затем посмотрите  непосредственного  предка  TLabel  в  иерархии  -
TStaticText. Поля    Owner   нет   опять.   Посмотрите   следующего
непосредственного предка TView.  Здесь Вы найдете полную информацию
об Owner, которое наследуется неизменным в TLabel.
     Каждый объект в этой  главе  имеет  графическое  представление
предков и  непосредственных  наследников так,  что Вы сможете легко
найти объекты, от которых наследуются поля и методы.
     Каждый объект представлен в следующем формате:

     Объект TSample                                  Модуль объекта
═══════════════════════════════════════════════════════════════════

                  ┌─────────┐
                  │ TObject │
                  └────┬────┘
                  ╔════╧════╗
                  ║ TSample ║
                  ╚════╤════╝
                ┌──────┴──────┐
                │ TDescendant │
                └─────────────┘

 Поля ─────────────────────────────────────────────────────────────

         Этот раздел приводит  список  всех  полей  объекта.  Кроме
         объявления поля и объяснения его  использования приводится
         назначение "только чтение" и "чтение/запись". Поля "только
         на  чтение"  -  это  поля,   которые   устанавливаются   и
         поддерживаются  методами  объектов  и  которые  не  должны
         использоваться в левой части оператора присваивания.

 AField  AField: SomeType;                            Только чтение
         AField - это поле,  которое содержит некоторую  информацию
         об этом    объекте.   Этот   текст   объясняет   как   оно
         функционирует, что   это   означает   и   как   Вам    его
         использовать.
         См. так же:  Связанные поля,  методы,  объекты, глобальные
         функции и т.д.

 AnotherField  AnotherField: Word;                    Чтение/Запись
         Это поле содержит информацию подобную информации  для поля
         AField.


 Методы ───────────────────────────────────────────────────────────

         Этот раздел приводит все методы, которые либо определены в
         этом объекте,  либо перекрывают унаследованные методы. Для
         виртуальных методов   указывается,   как  часто  требуется
         перекрывать метод:  никогда,  редко,  иногда,  часто   или
         всегда.

 Init    constructor Init(AParameter: SomeType);
         Init создает новый экземпляр  объекта,  устанавливая  поле
         AField в АParameter.

 Zilch   procedure Zilch; virtual;            Перекрывается: Иногда
         Процедура Zilch выполняет некоторые действия.
         См. так же TSomethingElse.Zilch


TApplication                                                    App
═══════════════════════════════════════════════════════════════════

                  ┌──────────┐
                  │ TObject  │
                  └────┬─────┘
                  ┌────┴─────┐
                  │  TView   │
                  └────┬─────┘
                  ┌────┴─────┐
                  │ TGroup   │
                  └─┬──┬───┬─┘
          ┌─────────┘  │   └─────────┐
     ┌────┴────┐  ┌────┴─────┐  ┌────┴─────┐
     │ TWindow │  │ TDeskTop │  │ TProgram │
     └────┬────┘  └──────────┘  └────┬─────┘
     ┌────┴────┐               ╔═════╧════════╗
     │ TDialog │               ║ TApplication ║
     └─────────┘               ╚══════════════╝

         TApplication просто наследуется от TProgram  и  отличается
         от TProgram    только    констрактором   и   дестрактором.
         TApplication.Init инициализирует  все   подсистемы   Turbo
         Vision (управление памятью,  видео,  событиями, системными
         ошибками и   списками   историй)    и    затем    вызывает
         TProgram.Init. Аналогично     TApplication.Done    вначале
         вызывает TProgram.Done,  а затем уничтожает все подсистемы
         Turbo Vision.
         Обычно Вы   будете   наследовать   свои    программы    от
         TApplication. Если       Вам       потребуется      другая
         последовательность инициализации подсистем и  их закрытия,
         Вы можете наследовать Вашу программу от TProgram и вручную
         инициализировать и закрывать подсистемы Turbo Vision.

 Методы ───────────────────────────────────────────────────────────

 Init   constructor Init;
         Фактическая реализация TApplication.Init показана ниже:

     constructor TApplication.Init;
     begin
       InitMemory;
       InitVideo;
       InitEvents;
       InitSysError;
       InitHistory;
       TProgram.Init;
     end;

         См. так же: TProgram.Init

 Done    destructor Done; virtual;
         Реализация TApplication.Done показана ниже:

     destructor TApplication.Done;
     begin
       TProgram.Done;
       DoneHistory;
       DoneSysError;
       DoneEvents;
       DoneVideo;
       DoneMemory;
     end;


TBackground                                                     App
═══════════════════════════════════════════════════════════════════

                  ┌─────────────┐
                  │   TObject   │
                  └──────┬──────┘
                  ┌──────┴──────┐
                  │    TView    │
                  └──────┬──────┘
                  ╔══════╧══════╗
                  ║ TBackGround ║
                  ╚═════════════╝

         TBackground -  это  простой  видимый  элемент,  содержащий
         однотонно заполненный прямоугольник. Обычно он принадлежит
         TDeskTop.

 Поля ─────────────────────────────────────────────────────────────

 Pattern   Pattern: Char;                             Только чтение
         Это битовый шаблон для фона видимого элемента.

 Методы ───────────────────────────────────────────────────────────

 Init   constructor Init(var Bounds: TRect; APattern: Char);
         Создает объект  TBackground  с  границами  Bounds  вызывая
         TView.Init.   GrowMode   устанавливается   в  gfGrowHiX  +
         gfGrowHiY,  а поле Pattern устанавливается в APattern. См.
         так же: TView.Init, TBackground.Pattern

 Load   constructor Load(var S: TStream);
         Создает объект TBackground и загружает его  из  потока  S,
         вызывая TView.Load, а затем читая поле Pattern.
         См. так же: TView.Load

 Draw   procedure Draw; virtual;               Перекрывается: Редко
         Заполняет прямоугольник видимого элемента текущим шаблоном
         с цветом по умолчанию.

 GetPalette   function GetPalette: PPalette; virtual;
                                               Перекрывается: Редко
         Возвращает указатель на палитру по умолчанию CBackground.

 Store  procedure Store(var S: TStream);
         Сохраняет видимый  элемент  TBackground в потоке,  вызывая
         TView.Store, а затем записывая поле Pattern.
         См. так же: TView.Store, TBackground.Load

 Палитра───────────────────────────────────────────────────────────

         Объекты фона  используют  по умолчанию палитру CBackground
         для отображения в первый элемент палитры программы.

                              1
                            ╔═══╗
              CBackground   ║ 1 ║
                            ╚═╤═╝
                   Color  ────┘


TBufStream                                                  Objects
═══════════════════════════════════════════════════════════════════

                  ┌────────────┐
                  │   TObject  │
                  └──────┬─────┘
                  ┌──────┴─────┐
                  │   TStream  │
                  └──────┬─────┘
                  ┌──────┴─────┐
                  │ TDosStream │
                  └──────┬─────┘
                  ╔══════╧═════╗
                  ║ TBufStream ║
                  ╚════════════╝

         TBufStream реализует  буферизованную  версию   TDosStream.
         Дополнительные поля указывают размер и положение буфера, а
         так же  текущую  и  последнюю  позицию  в  буфере.   Кроме
         перекрытия восьми     методов    TDosStream,    TBufStream
         определяет абстрактный  метод  TStream.Flush.  Констрактор
         TBufStream создает     и     открывает    файл,    вызывая
         TDosStream.Init, затем создает буфер с помощью GetMem.
         TBufStream значительно  эффективнее  TDosStream при работе
         большого числа небольших данных в  поток,  а  так  же  при
         сохранении и    загрузке    объектов    с   использованием
         TStream.Get и TStream.Put.

 Поля ─────────────────────────────────────────────────────────────

 Buffer  Buffer: Pointer;                             Только чтение
         Указатель на начало буфера потока.

 BufSize BufSize: Word;                               Только чтение
         Размер буфера в байтах.

 BufPtr  BufPtr: Word;                                Только чтение
         Смещение от   указателя  Buffer,  указывающее  на  текущую
         позицию внутри буфера.

 BufEnd  BufEnd: Word;                                Только чтение
         Если буфер не заполнен,  BufEnd дает смещение от указателя
         Buffer на последний используемый байт в буфере.


 Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(FileName: FNameStr; Mode, Size: Word);
         Создает и открывает файл с режимом доступа  Mode,  вызывая
         TDosStream.Init. Так  же создает буфер размером в SizeBuf,
         вызывая GetMem.  Handle, Buffer и BufSize инициализируются
         соответственно. Типичный  размер  буфера  от  512  до 2048
         байт.
         См. так же: TDosStream.Init

 Done    destructor Done; virtual;           Перекрывается: Никогда
         Закрывает и  освобождает  файловый  поток;  выталкивает  и
         освобождает его буфер.
         См. так же: TBufStream.Flush

 Flush   procedure Flush; virtual;           Перекрывается: Никогда
         Выталкивает буфер потока,  обеспечивая,  что поток будет в
         состоянии stOK.
         См. так же: TBufStream.Done

 GetPos  function GetPos: LongInt; virtual;  Перекрывается: Никогда
         Возвращает значение текущей позиции потока (не перепутайте
         с BufPtr - текущей позицией в буфере).
         См. так же: TBufStream.Seek

 GetSize function GetSize: LongInt; virtual; Перекрывается: Никогда
         Выталкивает буфер,  а  затем возвращает общее число байт в
         потоке.

 Read    procedure Read(var Buf; Count: Word); virtual;
                                             Перекрывается: Никогда
         Если stOK,  читает Count  байт  в  буфер  Buf,  начиная  с
         текущей позиции потока.
         Заметим, что Buf - это не буфер потока,  а внешний  буфер,
         содержащий данные читаемые из потока.
         См. так же: TBufStream.Write, stReadError

 Seek    procedure Seek(Pos: LongInt); virtual;
                                             Перекрывается: Никогда
         Выталкивает буфер, а затем устанавливает текущую позицию в
         Pos байт от начала потока. Начальная позиция потока - 0.
         См. так же: TBufStream.GetPos, TBufStream.GetSize

 Truncate procedure Truncate; virtual;       Перекрывается: Никогда
         Выталкивает буфер,  затем  удаляет  все  данные  потока от
         текущей позиции   до   конца   потока.   Текущая   позиция
         устанавливается в новый конец потока.
         См. так же: TbufStream.GetPos, TBufStream.Seek

 Write   procedure Write(var Buf; Count: Word); virtual;
                                             Перекрывается: Никогда
         Если stOK,  записывает Count байт из буфера Buf  в  поток,
         начиная с текущей позиции.
         Заметим, что Buf - это не буфер потока,  а внешний  буфер,
         содержащий данные,   записываемые  в  поток.  Когда  Write
         вызывается, Buf указывает  на  переменную,  чье  значяение
         записывается.
         См. так же: TBudStream.Read, stWriteError


TButton                                                     Dialogs
═══════════════════════════════════════════════════════════════════

                  ┌───────────┐
                  │  TObject  │
                  └─────┬─────┘
                  ┌─────┴─────┐
                  │   TView   │
                  └─────┬─────┘
                  ╔═════╧═════╗
                  ║  TButton  ║
                  ╚═══════════╝

         Объект TBuuton  -  это прямоугольник с заголовком и тенью,
         генерирующий команду при нажатии.  Эти  кнопки  интенсивно
         используются в  IDE.  Кнопка  может  быть выбрана нажатием
         подсвеченной буквы,  переходом на кнопку с помощью  Tab  и
         нажатием пробела,   нажатием   Enter,   когда   кнопка  по
         умолчанию (указывается  подсветкой)  или  отметкой  кнопки
         мышкой.
         При цветной и черно-белой палитрах кнопка имеет трехмерный
         вид, который   изменяется   при  нажатии.  На  монохромных
         системах кнопка выделена стрелками и другие  ASCII символы
         используются для указания, является ли кнопка по умолчанию
         выбранной и т.д.
         Как и  другие  элементы управления,  определенные в модуле
         Dialogs, TButton - это терминальный объект.  Он может быть
         вставлен в  любую  группу и использован без перекрытия его
         методов.
         Кнопка инициализируется    передачей   ей   TRect   строки
         заголовка, команды,  генерируемой  при  нажатии  кнопки  и
         байта флагов.   Чтобы   определить   для   кнопки  клавишу
         короткого набора,  строка заголовка  может  содержать  "~"
         вокруг одного  из  символов,  который  становится символом
         короткого набора.   Параметр   AFlag   указывает,    будет
         заголовок центрироваться   или   выравниваться   по  левой
         границе и  должна   ли   кнопка   быть   умалчиваемой   (и
         следовательно выбираться через Enter).
         Вы можете установить в окне  или  диалоговом  окне  только
         одну кнопку  по умолчанию в любой момент времени.  Кнопки,
         которые равны в группе,  получают  и  отдают  умалчиваемое
         состояние через  сообщения evBroadcast.  Кнопки могут быть
         разрешены или запрещены с использованием  методов SetState
         и CommandEnabled.

 Поля ─────────────────────────────────────────────────────────────

 Title  Title: PString;                               Только чтение
         Указатель на текст кнопки.

 Command Commаnd: Word;                               Только чтение
         Слово команды в событии, генерируемом при нажатии кнопки.
         См. так же: TButton.Init, TButton.Load

 Flags   Flags: Byte;                                 Чтение/Запись
         Flags -  это  поле,  используемое  для указания,  будет ли
         текст кнопки  центрироваться  или   выравниваться   влево.
         Отдельные флаги  описаны в разделе "Константы флага кнопки
         bfXXXX" главы 14.
         См. так же: TButton.Draw, константы bfXXXX

 AmDefault  AmDefault: Boolean;                       Только чтение
         Если True,  кнопка  -  по   умолчанию   (и   следовательно
         выбирается при  нажатии  Enter).  Иначе - это "нормальная"
         кнопка.
         См. так же: Константы флага кнопки bfXXXX

 Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(var Bounds: TRect; ATitle: TTitleStr;
                          ACommand: Word; AFlags: Byte);
         Создает объект TButton с заданным размером, вызывая TView.
         Init. Вызывается NewStr(ATitle)  и  назначается  в  Title.
         AFlags используется   в   двух   целях:  если  AFlags  and
         bfDefault - не 0,  то AmDefault  устанавливается  в  True;
         кроме того,     AFlags    указывает,    будет    заголовок
         центрироваться или  выравниваться  влево  проверкой   если
         AFlags and bfLeftJust не 0.
         Options устанавливается в (ofSelectable +  ofFirstClick  +
         ofPreProcess + ofPostProcess). EventMask устанавливается в
         evBroadсast. Если данная ACommand  не  разрешена,  в  поле
         State устанавливается sfDisabled.
         См. так же: TView.Init, константы флага кнопки bfXXXX

 Load    constructor Load(var S: TStream);
         Создает объект  TButton  и инициализирует его из заданного
         потока, вызывая TView.Load(S). Другие поля устанавливаются
         через вызовы    S.Read,    а   State   устанавливается   в
         соответствии с тем,  разрешена ли команда в поле  Command.
         Используется совместно  с  TButton.Store  для сохранения и
         получения объекта в TButton из TStream.
         См. так же: TView.Load, TButton.Store

 Done    destructor Done; virtual;           Перекрывается: Никогда
         Освобождает память,  распределенную   под   Title,   затем
         вызывает TView.Done для разрушения видимого элемента.
         См. так же: TView.Done

 Draw    procedure Draw; virtual;              Перекрывается: Редко
         Рисует кнопку  соответствующей  палитрой  для  ее текущего
         состояния (нормальная   по    умолчанию    запрещена)    и
         позиционирует метку в соответствии с битом bfLeftJust поля
         Flags.

 GetPalette function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель на палитру по умолчанию CButton.

 HandleEvent procedure HandleEvent(var Event: TEvent); virtual;
                                              Перекрывается: Иногда
         Отвечает на  нажатие  одним  из  трех  способов:  отметкой
         кнопки мышкой,  нажатием  короткой  клавиши или становится
         кнопкой по  умолчанию,  когда  получено  общее   сообщение
         cmDefault. Когда  кнопка  нажата,  генерируется  командное
         событие с   TView.PutEvent,   с   полем   TButton.Command:
         установленным в     Event.Command,     а     Event.InfoPtr
         установленным в @Self.
         Кнопки так  же  распознают  общие  команды cmGrabDefault и
         cmReleaseDefault, чтобы стать или "не  стать"  кнопкой  по
         умолчанию и  cmCommandSetChanged,  которая  заставляет  их
         проверять, разрешены команды или запрещены.
         См. так же: TView.HandleEvent

 MakeDefault  procedure MakeDefault(Evable: Boolean);
         Этот метод ничего не делает, если кнопка уже умалчиваемая.
         Иначе говорит  Owner  в  кнопке  измениться в состояние по
         умолчанию. Если  Enable  True,  выдается   общая   команда
         cmGrebDefault, иначе        cmReleaseDefault.       Кнопка
         перерисовывается, чтобы показать новый статус.
         См. так же: TButton.AmDefault, bfDefault

 SetState procedure   SetState(AState:   Word;   Enable:  Boolean);
         virtual;                              Перекрывается: Редко
         Вызывает TView.SetState,  затем рисует кнопку, если кнопка
         стала sfSelected или sfActive. Если она стала активной (т.
         е. если  AState  -  sfFocused)  кнопка забирает или отдает
         состояние по  умолчанию  кнопке  по   умолчанию,   вызывая
         MakeDefault.
         См. так же: TCView.SetState, TButton.MakeDefault

 Store  procedure Store(var S: TStream);
         Сохраняет объект TButton в потоке, вызывая TView.Store(S),
         а затем S.Write для сохранения значений Title  и  Command.
         Используется совместно  с  TButton.Load  для  сохранения и
         получения  объектов  TButton  из  потока.  См.   так   же:
         TView.Store, TButton.Load, TStream.Write

Палитра────────────────────────────────────────────────────────────

         Объект кнопка  использует палитру по умолчанию CButton для
         отображения элементов от 10 до 15 в палитру CDialog.


              1    2    3    4    5    6    7    8
           ╔════╤════╤════╤════╤════╤════╤════╤════╗
CButton    ║ 10 │ 11 │ 12 │ 13 │ 14 │ 14 │ 14 │ 15 ║
           ╚══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧═╤══╝
Нормальный  ──┘    │    │    │    │    │    │   └ Тень
текст              │    │    │    │    │    │
Текст по     ──────┘    │    │    │    │    └──── Выбранная
умолчанию               │    │    │    │          короткая клавиша
Выбранный     ──────────┘    │    │    └───────── Короткая клавиша
текст                        │    │               по умолчанию
Запрещенный   ───────────────┘    └────────────── Выбранная
текст                                             нормальная
                                                  клавиша


TCheckBoxes                                                 Dialogs
═══════════════════════════════════════════════════════════════════

                  ┌────────────┐
                  │   TObject  │
                  └──────┬─────┘
                  ┌──────┴─────┐
                  │    TView   │
                  └──────┬─────┘
                  ┌──────┴─────┐
                  │  TCluster  │
                  └────┬───┬───┘
              ┌────────┘   └───────┐
      ┌───────┴───────┐     ╔══════╧══════╗
      │ TRadioButtons │     ║ TCheckBoxes ║
      └───────────────┘     ╚═════════════╝

         TCheckBoxes - это кластер,  содержащий от 1 до 16 элементв
         управления. В  отличие  от  зависимых кнопок,  любое число
         независимых кнопок  может  быть  установлено   независимо.
         Поэтому в  этой  группе  нет  кнопки по умолчанию.  Кнопки
         можно отмечать  мышкой,  движением  курсора   и   коротким
         нажатием Alt-буква.  Каждая кнопка может быть подсвечена и
         включена/выключена (пробелом).   Если   кнопка    выбрана,
         появляется Х.   Другие   части   Вашей   программы  обычно
         проверяют состояние независимых  кнопок  для  определения,
         какая опция  выбрана  пользователем  (например в IDE опции
         компилятора и  редактора   выбираются   таким   способом).
         Кластеры независимых  кнопок  часто  связаны  с  объектами
         TLabel.

 Поля ─────────────────────────────────────────────────────────────

         Наследуют поля ValueSl от TCluster. Value интерпретируется
         как набор  из  16  бит (от 0 до 15),  где 1 в бите позиции
         означает, что соответствующий элемент отмечен.

 Методы ───────────────────────────────────────────────────────────

         Заметим, что  TCheckBoxes  не  перекрывает  констракторов,
         дестрактора и  обработчика  событий TCluster.  Порожденные
         типы объектов могут однако перекрыть их.

 Draw    procedure Draw; virtual;              Перекрывается: Редко
         Рисует объект   TCheckBoxes   вызывая   наследуемый  метод
         TCluster.DrawBox. По умолчанию  независимая  кнопка  имеет
         вид: " [ ] " когда не выбрана и " [X] " когда выбрана.
         Заметим, что если  границы  видимого  элемента  достаточно
         велики, независимые  кнопки могут отображаться в несколько
         колонок.
         См. так же: TCluster.DrawBox

 Mark    function Mark(Item: Integer) : Boolean; virtual;
                                               Перекрывается: Редко
         Возвращает True,  если  бит  элемента  в Value установлен,
         т.е. если данная кнопка отмечена. Вы можете перекрыть это,
         установив другую  интерпретацию  поля Value.  По умолчанию
         элементы нумеруются от 0 до 15.
         См. так же: TCheckBoxes.Press

 Press   procedure Press(Item: Integer); virtual;
                                               Перекрывается: Редко
         Устанавливает бит элемента в Value.  Вы  можете  перекрыть
         его для  другой  интерпретации  поля  Value.  По умолчанию
         элементы нумеруются от 0 до 15.
         См. так же: TCheckBoxes.Mark


 Палитра───────────────────────────────────────────────────────────

         По умолчанию   объекты   независимых   кнопок   используют
         CCluster -    палитру    по     умолчанию     для     всех
         объектов-кластеров.


                      1    2    3    4
                   ╔════╤════╤════╤════╗
      CCluster     ║ 16 │ 17 │ 18 │ 18 ║
                   ╚══╤═╧══╤═╧══╤═╧══╤═╝
      Нормальный  ────┘    │    │    └─── Выбранная короткая
      текст                │    │         клавиша
      Выбранный     ───────┘    └──────── Нормальная короткая
      текст                               клавиша


TCluster                                                    Dialogs
═══════════════════════════════════════════════════════════════════

                  ┌────────────┐
                  │   TObject  │
                  └──────┬─────┘
                  ┌──────┴─────┐
                  │    TView   │
                  └──────┬─────┘
                  ╔══════╧═════╗
                  ║  TCluster  ║
                  ╚════╤═══╤═══╝
              ┌────────┘   └───────┐
      ┌───────┴───────┐     ┌──────┴──────┐
      │ TRadioButtons │     │ TCheckBoxes │
      └───────────────┘     └─────────────┘

         Кластер -   это   группа   элементов  управления,  которые
         откликаются одинаково.  TCluster  -  это  абстрактный  тип
         объекта, из    которого   порождаются   группы   элементов
         управления TRadioButtons    и    TCheckBoxes.     Элементы
         управления кластера   часто   ассоциируются   с  объектами
         TLabel, позволяя Вам выбирать элемент  управления, выбирая
         дополнительную метку с объяснением.
         В то время,  как кнопки используются для генерации команд,
         а строки   ввода  -  для  редактирования  строк,  кластеры
         используются для переключения битовых значений  поля Value
         (типа Word).  Стандартные  наследники  TCluster используют
         различные алгоритмы изменения  Value:  TCheckBoxes  просто
         переключает бит,  а  TRadioButtons  включает  один  бит  и
         очищает предварительно   выбранный   бит.   Оба    объекта
         наследуют почти все свое поведение от TCluster.


 Поля ─────────────────────────────────────────────────────────────

 Value  Value: Word;                                  Только чтение
         Текущие значения   элемента   управления.  Действительнвый
         смысл этого поля определяется методами,  разработанными  в
         типах объектов, порожденных от TCluster.

 Sel     Sel: Integer;                                Только чтение
         Текущий выбранный элемент кластера.

 Strings Strings: TStringCollection;                  Только чтение
         Список элементов кластера.


 Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(var Bounds: TRect; AStrings: PSItem);
         Очищает поля   Value   и  Sel.  Параметр  AStrings  обычно
         выполняет серию  вложенных  вызовов   глобальной   функции
         NewSItem. Таким   образом   весь   кластер  зависимых  или
         независимых кнопок  может  быть   создан   одним   вызовом
         констрактора:

      var
        Control: PView;
      ...
      R.Assign(30, 5, 52, 7);
      Control := New(PRadioButtons, Init(R,
        NewSItem('~F~orward',
        NewSItem('~B~ackward', nil))));
      ...

         Когда в кластер добавляются дополнительные  зависимые  или
         независимые кнопки,   просто   копируется   первый   вызов
         NewSItem и заголовок заменяется требуемым  текстом.  Затем
         добавляется дополнительная  закрывающая  скобка для каждой
         новой добавленной строки и оператор  будет компилироваться
         без синтаксических ошибок.
         См. так же: тип TSItem

 Load    constructor Load(var S: TStream);
         Создает объект   TCluster,  вызывая  TView.Load(S),  затем
         устанавливает поля Value и  Set  вызовом  S.Read.  Наконец
         поле String   кластера   загружается   из   S   с  помощью
         Strings.Load(S). Используется совместно  с  TCluster.Store
         для сохранения и получения объектов TCluster из потока.
         См. так же: TCluster.Store, TView.Load

 Done    destructor Done; virtual;            Перекрывается: Иногда
         Освобождает память,  распределенную  под  строку кластера,
         затем разрушает видимый элемент, вызывая TView.Done.
         См. так же: TView.Done

 DataSize function DataSize: Word; virtual;    Перекрывается: Редко
         Возвращает размер   Value.    Должен    перекрываться    в
         порожденных типах  объектов,  которые  изменяют  Value или
         добавляют другие поля данных для того,  чтобы  работать  с
         GetData и SetData.
         См. так же: TCluster.GetData, TCluster.SetData

 DrawBox procedure DrawBox(Icon: String; Maker: Char);
         Вызывается методом Draw порожденного типа,  чтобы рисовать
         прямоугольник перед строкой для каждого элемента кластера.
         Icon - это строка из 5 символов (' [ ] ' для независимых и
         ' ( )  '  для  зависимых  кнопок).  Maker  -  это  символ,
         используемый для  указания,  что  кнопка отмечена ('X' для
         зависимых и '.' для независимых кнопок).
         См. так же: TCheckBoxes.Draw, TRadioButtons.Draw

 GetData procedure GetData(var Rec); virtual;  Перекрывается: Редко
         Записывает поле Value в данную запись  и  рисует  кластер.
         Должен перекрываться в порожденных типах объектов, которые
         изменяют поле Value для того,  чтобы работать с DataSize и
         SetData.
         См. так    же:    TCluster.DataSize,     TCluster.SetData,
                           TView.DrawView

 GetHelpCtx function GetHelpCtx: Word; virtual; Перекрывается:Редко
         Возвращает значение  Sel  добавленное   к   HelpCtx.   Это
         позволяет Вам  задать  отдельную  констекстную справку для
         каждого элемента кластера.  Допустимый диапазон контекстов
         равен HelpCtx плюс число элементов кластера минус 1.

 GetPalette function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель на палитру по умолчанию CCLuster.

 HandleEvent procedure HandleEvent(var Event: TEvent); virtual;
                                               Перекрывается: Редко
         Вызывает TView.HandleEvent,   который   обрабатывает   все
         события от  мышки  и  клавиатуры,  относящиеся   к   этому
         кластеру. Элементы  управления  выбираются  отметкой мышки
         или клавишами движения курсора (включая  Пробел).  Кластер
         перерисовывается, чтобы показать выбранные элементы.
         См. так же: TView.HandleEvent

 Mark   function Mark(Item: Integer): Boolean; virtual;
                                              Перекрывается: Всегда
         Вызывается из  Draw  для   определения,   какие   элементы
         отмечены. По  умолчанию  TCluster.Mark  возвращает  False.
         Mark должен перекрываться,  возвращая True,  если  элемент
         управления в кластере отмечен, иначе False.

 MovedTo procedure MovedTo(Item: Integer); virtual;
                                               Перекрывается: Редко
         Вызывается из HandleEvent для перемещения полосы выбора на
         заданный элемент управления в кластере.

 Press   procedure Press(Item: Integer); virtual;
                                              Перекрывается: Всегда
         Вызывается из  HandleEvent  когда  элемент  управления   в
         кластере нажат  либо  отметкой  мышки,  либо  событием  от
         клавиатуры. Этот абстрактный метод должен быть перекрыт.

 SetData procedure SetData(var Rec); virtual;  Перекрывается: Редко
         Читает поле   Value  из  данной  записи  и  перерисовывает
         кластер. Должен   перекрываться   в   порожденных    типах
         кластеров, которые   требуют  другие  поля  для  работы  с
         DataSize и GetData.
         См. так     же:    TCluster.DataSize,    YCluster.GetData,
                            TView.DrawView

 SetState procedure SetState(AState: Word; Enable: Boolean);
          virtual;                             Перекрывается: Редко
         Вызывает TView.SetState, затем рисует кластер, если AState
         - sfSelected.
         См. так же: TView.SetState, TView.DrawView

 Store  procedure Store(var S: TStream);
         Сохраняет объект     TCluster     в     потоке,    вызывая
         TView.Store(S), записывает Value и  Sel,  затем  сохраняет
         поле Strings   кластера,   используя   его   метод  Store.
         Используется совместно с TCluster.Load  для  сохранения  и
         получения объектов TCluster из потока.
         См. так же: TCluster.Load, TStream.Write

 Палитра───────────────────────────────────────────────────────────

         Объекты TCluster  используют   CCluster   -   палитру   по
         умолчанию  для  всех  объектов кластера,  чтобы отобразить
         элементы с 16 по 18  в  палитру  стандартного  диалогового
         окна:

                      1    2    3    4
                   ╔════╤════╤════╤════╗
      CCluster     ║ 16 │ 17 │ 18 │ 18 ║
                   ╚══╤═╧══╤═╧══╤═╧══╤═╝
      Нормальный  ────┘    │    │    └─── Выбранная короткая
      текст                │    │         клавиша
      Выбранный     ───────┘    └──────── Нормальная короткая
      текст                               клавиша


TCollection                                                 Objects
═══════════════════════════════════════════════════════════════════

                        ┌─────────┐
                        │ TObject │
                        └────┬────┘
                      ╔══════╧══════╗
                      ║ TCollection ║
                      ╚══════╤══════╝
                   ┌─────────┴─────────┐
                   │ TSortedCollection │
                   └─────────┬─────────┘
                   ┌─────────┴─────────┐
                   │ TStringCollection │
                   └─────────┬─────────┘
                  ┌──────────┴──────────┐
                  │ TResourceCollection │
                  └─────────────────────┘

         TCollection -  это  абстрактный  тип  для реализации любой
         коллекции элементов,  включая другие объекты.  TCollection
         это намного  более  общая  концепция,  чем обычные массив,
         множество или   список.   Размер   объектов    TCollection
         динамически устанавливается    во   время   выполнения   и
         TCollection - базовый тип  для  многих  специализированных
         типов,  таких  как TSortedCollection,  TStringCollection и
         TResourceCollection. В дополнение к методам  добавления  и
         удаления элементов   TCollection   представляет  несколько
         итераторных программ,  которые  вызывают   процедуру   или
         функцию для каждого элемента коллекции.

 Поля ─────────────────────────────────────────────────────────────

 Items  Items: PItemList;                             Только чтение
         Указатель на массив указателей элементов.
         См. так же: тип TItemList

 Count   Count: Integer;                              Только чтение
         Текущее число   элементов   в    коллекции,    максимально
         MaxCollectionSize.
         См. так же: переменная MaxCollectionSize

 Limit   Limit: Integer;                              Только чтение
         Текущий распределенный размер (в элементах) списка Items.
         См. так же: Delta, TCollection.Init

 Delta   Delta: Integer;                              Только чтение
         Число элементов, на которое увеличивается список Items при
         заполнении. Если Delta - 0,  коллекция не может расти выше
         размера, установленного в Limit.

         Примечание: Увеличение размера коллекции достаточно дорого
         в смысле производительности.  Чтобы  минимизировать  число
         раз когда это происходит, попытайтесь установить начальное
         Limit в такое количество,  которое  будет  достаточно  для
         всех элементов,  которые Вы собираетесь коллекционировать,
         и установите Delta так,  чтобы она позволяла расширение на
         приемлемое количество.
         См. так же: Limit, TCollection.Init

 Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(ALimit, ADelta: Integer);
         Создает коллекцию с Limit, установленным в ALimit и Delta,
         установленным в  ADelta.  Первоначальное  число  элементов
         будет ограничено  ALimit,  но коллекция может расширяться,
         увеличиваясь по ADelta до тех пор,  пока будет  достаточно
         памяти или    пока    число    элементов    не   достигнет
         MaxCollectionSize.
         См. так же: TCollection.Limit, TCollection.Delta.

 Load    constructor Load(var S: TStream);
         Создает и загружает коллекцию из  потока. TCollection.Load
         вызывает GetItem для каждого элемента коллекции.
         См. так же: TCollection.GetItem

 Done   destructor Done; virtual;              Перекрывается: Часто
         Удаляет и  освобождает  все  элементы  коллекции,  вызывая
         TCollection.FreeAll и устанавливая Limit в 0.
         См. так же: TCollection.FreeAll, TCollection.Init

 At      function At(Index: Integer) : Pointer;
         Возвращает указатель  на  элемент  с  индексом   Index   в
         коллекции. Этот   метод   позволяет  Вам  интерпретировать
         коллекцию как индексированный массив. Если индекс меньше 0
         или больше  или  равно  Count,  вызывается  метод  Error с
         аргументом coIndexError и возвращается значение nil.
         См. так же: TCollection.IndexOf

 AtDelete procedure AtDelete(Index: Integer);
         Удаляет элемент в позиции  Index  и  перемещает  следующие
         элементы на одну позицию вверх. Count уменьшается на 1, но
         память,  распределенная под коллекцию (как задано в Limit)
         не  сокращается.  Если Index меньше 0 или больше или равно
         Count,  вызывается  метод Error с аргументом coIndexError.
         См.   так   же:   TCollection.FreeItem,  TCollection.Free,
         TCollection.Delete

 AtInsert procedure AtInsert(Index: Integer; Item: Pointer);
         Вставляет Item  в  позицию  Index  и передвигает следующие
         элементы на одну позицию вниз.  Если Index  меньше  0  или
         больше Count,   вызывается   метод   Error   с  аргументом
         coIndexError и новый Item не вставляется. Если Count равен
         Limit до вызова AtInsert,  распределенный размер коллекции
         расширяется на Delta  элементов,  вызывая  SetLimit.  Если
         вызов SetLimit  не  может расширить коллекцию,  вызывается
         метод Error  с  аргументом  coOverflow  и  новый  Item  не
         вставляется.
         См. так же: TCollection.At, TCollection.AtPut

 AtPut   procedure AtPut(Index: Integer; Item: Pointer);
         Заменяет элемент  в  позиции  Index элементом,  заданным в
         Item. Если Index меньше 0  или  больше  или  равно  Count,
         вызывается метод Error с аргументом coIndexError.
         См. так же: TCollection.At, TCollection.AtInsert

 Delete  procedure Delete(Item: Pointer);
         Удаляет элемент    Item    из    коллекции.   Эквивалентно
         AtDelete(IndexOf(Item)).
         См. так же: TCollection.AtDelete, TCollection.DeleteAll

 DeleteAll procedure DeleteAll;
         Удаляет все элементы из коллекции, устанавливая Count в 0.
         См. так же: TCollection.Delete, TCollection.AtDelete

 Error   procedure Error(Code, Info: Integer); virtual;
                                              Перекрывается: Иногда
         Вызывается, когда   встречается   ошибка   коллекции.   По
         умолчанию этот метод генерирует ошибку  времени выполнения
         212.
         См. так же: константы коллекции coXXXX

 FirstThat function FirstThat(Test: Pointer) : Pointer;
         FirstThat применяет булевскую функцию, заданную указателем
         на функцию Test к каждому элементу коллекции до  тех  пор,
         пока  test  возвращает  True.  Результат  -  указатель  на
         элемент, для которого Test возвращает True,  или nil, если
         функция Test  возвращает  False  для всех элементов.  Test
         должна указывать    на    дальнюю    локальную    функцию,
         использующую только   один   параметр   типа   Pointer   и
         возвращающую значение типа Boolean. Например

         function Matches(Item: Pointer) : Boolean; far;

         Функция Test не может быть глобальной функцией.
         Предполагая, что List типа TCollection, оператор

         P := List.FirstThat(@Matches);

         соответствует

     I := 0;
     while (I < List.Count) and not Matches(List.At(I)) do Inc(I);
     if I < List.Count then P := List.At(I) else P := nil;

         См. так же: TCollection.LastThat, TCollection.ForEach

 ForEarch procedure ForEarch(Action: Pointer);
         ForEach применяет действие,  определенное  процедурой,  на
         которую указывает Action,  для каждого элемента коллекции.
         Action должен указывать на  локальную  дальнюю  процедуру,
         использующую один параметр типа Pointer. Например

         function PrintItem(Item: Pointer);

         Процедура Action не может быть глобальной процедурой.
         Если List типа TCollection, оператор

         List.ForEach(@PrintItem);

         соответствует

         for I := 0 to List.Count - 1 do PrintItem(List.At(I));

         См. так же: TCollection.FirstThat, TCollection.LastThat

 Free    procedure Free(Item: Pointer);
         Удаляет и освобождает Item. Эквивалентно

         FreeItem(Item);
         Delete(Item);

         См. так же: TCollection.FreeItem, TCollection.Delete

 FreeAll procedure FreeAll;
         Удаляет и освобождает все элементы коллекции.

         См. так же: TCollection.DeleteAll

 FreeItem procedure FreeItem(Item: Pointer); virtual;
                                              Перекрывается: Иногда
         Метод FreeItem   должен  освобождать  Item.  По  умолчанию
         TCollection.FreeItem предполагает,   что   Item   -    это
         указатель на  объект,  порожденный  от  TObject  и поэтому
         вызывает дестрактор Done:

         if Item <> nil then dispopse(PObject(Item), Done);

         FreeItem вызывается из  Free  и  FreeAll,  но  никогда  не
         должен вызываться прямо.

         См. так же: TCollection.Free, TCollection.FreeAll

 GetItem function   TCollection.GetItem(var  S:  TStream): Pointer;
                    virtual;                  Перекрывается: Иногда
         Вызывается из   TCollection.Load   для   каждого  элемента
         коллекции. Этот метод может быть перекрыт,  но  не  должен
         вызываться напрямую.   По   умолчанию  TCollection.GetItem
         предполагает, что элементы коллекции порождены  от TObject
         и вызывает TString.Get для загрузки элемента:

         GetItem := S.Get;

         См. так       же:      TStream.Get,      TCollection.Load,
         TCollection.Store

 IndexOf functionIndexOf(Item: Pointer): Integer; virtual;
                                             Перекрывается: Никогда
         Возвращает индекс  для  Item.   Преобразует   операцию   в
         TCollection.At. Если   Item  -  не  в  коллекции,  IndexOf
         возвращает -1.

         См. так же: TCollection.At

 Insert  procedure Insert(Item: Pointer); virtual;
                                             Перекрывается: Никогда
         Вставляет Item в коллекцию,  перестраивая другие  индексы,
         если необходимо. По умолчанию вставка производится в конец
         коллекции вызовом AtInsert(Count, Item);

         См. так же: TCollection.AtInsert;

 LastThat function LastThat(Test: Pointer): Pointer;
         LastThat применяет булевскую функцию,  заданную указателем
         на функцию Test,  к каждому элементу коллекции в  обратном
         порядке до тех пор,  пока Test не вернет True. Результат -
         указатель на элемент,  для которого Test возвращает  True,
         или nil,  если  функция  Test  возвращает  False  для всех
         элементов. Test  должен  указывать  на  дальнюю  локальную
         функцию, использующую   один   параметр   типа  Pointer  и
         возвращающую типа Boolean, например

         function Patches(Item: Pointer): Boolean; far;

         Функция Test не может быть глобальной функцией.
         Если List типа TCollection, оператор

         P := List.LastThat(@Matches);

         соответствует

         I := List.Count - 1;
         while (I >= 0) and Matches(List.At(I)) do Dec(I);
         if I >= 0 then P := List.At(I) else P := nil;

         См. так же: TCollection.FirstThat, TCollection.ForEach;

 Pack    Procedure Pack;
         Удаляет все nil указатели в коллекции.

         См. так же: TCollection.Delete, TCollection.DeleteAll

 PutItem procedure PutItem(var S: TStream; Item: Pointer); virtual;
                                              Перекрывается: Иногда
         Вызывается из  TCollection.Store  для   каждого   элемента
         коллекции.  Этот  метод может быть перекрыт,  но не должен
         вызываться прямо.   По    умолчанию    TCollection.PutItem
         предполагает, что   элементы   коллекций   порождаются  от
         TObject и вызов TString.Put сохраняет элемент:

         S.Put(Item);

         См. так   же:   TCollection.GetItem,    TCollection.Store,
         TCollection.Load

 SetLimit procedure SetLimit(ALimit: Integer); virtual;
                                               Перекрывается: Редко
         Расширяет или сокращает коллекцию,  изменяя распределенный
         размер в   ALimit.   Если   ALimit   меньше   Count,    он
         устанавливается в    Count,    и    если   ALimit   больше
         MaxCollectionSize, он устанавливается в MaxCollectionSize.
         Кроме того,  если  ALimit   отличается  от текущего Limit,
         распределяется новый массив  Items  из  Alimit  элементов,
         старый  массив  Items  копируется  в новый массив и старый
         массив освобождается.

         См.так же:    TCollection.Limit,    TCollection.Count,
                       переменная MaxCollectionSize

 Store   procedure Store(var S: TStream);
         Сохраняет коллекцию  и  все  ее  элементы  в   потоке   S.
         TCollection.Store вызывает TCollection.PutItem для каждого
         элемента коллекции.

         См. так же: TCollection.PutItem


TDeskTop                                                        App
═══════════════════════════════════════════════════════════════════

                    ┌─────────┐
                    │ TObject │
                    └────┬────┘
                    ┌────┴────┐
                    │  TView  │
                    └────┬────┘
                    ┌────┴────┐
                    │ TGroup  │
                    └─┬──┬──┬─┘
           ┌──────────┘  │  └────────────┐
      ┌────┴────┐   ╔════╧═════╗  ┌──────┴───────┐
      │ TWindow │   ║ TDeskTop ║  │ TProgram     │
      └────┬────┘   ╚══════════╝  └──────┬───────┘
      ┌────┴────┐                 ┌──────┴───────┐
      │ TDialog │                 │ TApplication │
      └─────────┘                 └──────────────┘

         TDescTop - это простая  группа,  которая  владеет  видимым
         элементом TBackground, на котором появляются окна и другие
         видимые элементы программы.  TDeskTop представляет область
         панели экрана,  располагаемой между верхней полосой меню и
         нижней строкой статуса.

Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(var Bounds: TRect);
         Создает группу  TDeskTop  с размером Bounds.  По умолчанию
         GrowMode установлена в gfGrowHiX + gfGrowHiY.  Init так же
         вызывает NewBackground   для   вставки  видимого  элемента
         TBackgroud в группу.

         См. так     же:    TDeskTop.NewBackGround,    TGroup.Init,
         TGroup.Insert

 Cascade procedure Cascade(var R: TRect);
         Заново отображает все окна, принадлежащие панели экрана, в
         каскадном формате.  Первое окно в Z порядке (самое нижнее)
         расширяется на всю панель  экрана,  а  каждое  последующее
         окно заполняет область, начинающуюся на одну строку ниже и
         на одну колонку  правее,  чем  предыдущее.  Активное  окно
         появляется на вершине как самое наименьшее.

         См. так же: ofTileable, TDeskTop.Tile

 NewBackGround function NewBackGround: PView; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель на фон, используемый в панели экрана.
         Этот метод вызывается в методе  TDeskTop.Init. Наследуемые
         объекты могут изменить тип фона, перекрывая этот метод.

         См. так же: TDeskTop.Init

 HandleEvent procedure HandleEvent(var Event: TEvent); virtual;
                                               Перекрывается: Редко
         Вызывает TGroup.HandleEvent  и отрабатывает команды cmNext
         (обычно горячая  клавиша  F6)  и  cmPrevious   циклическим
         проходом по  окнам (начиная с текущего выбранного видимого
         элемента) принадлежащим панели экрана.

         См. так же: TGroup.HandleEvent, константы команд cmXXXX

 Tile    procedure Tile(var R: TRect);
         Заново отображает   все  видимые  элементы  с  ofTileable,
         принадлежащие панели экрана в черепичном формате.

         См. так же: TDeskTop.Cascade, ofTileable

 TileError procedure TileError; virtual;      Перекрывается: Иногда
         TileError вызывается, если возникла ошибка во время работы
         TDeskTop.Tile или TDeskTop.Cascade. По умолчанию ничего не
         делает. Вы    можете    перекрыть    ее,   чтобы   указать
         пользователю, что программа не может реорганизовать окна.

         См. так же: TDeskTop.File, TDeskTop.Cascade


TDialog                                                     Dialogs
═══════════════════════════════════════════════════════════════════

                    ┌─────────┐
                    │ TObject │
                    └────┬────┘
                    ┌────┴────┐
                    │  TView  │
                    └────┬────┘
                    ┌────┴────┐
                    │ TGroup  │
                    └─┬──┬──┬─┘
           ┌──────────┘  │  └────────────┐
      ┌────┴────┐   ┌────┴─────┐  ┌──────┴───────┐
      │ TWindow │   │ TDeskTop │  │ TProgram     │
      └────┬────┘   └──────────┘  └──────┬───────┘
      ╔════╧════╗                 ┌──────┴───────┐
      ║ TDialog ║                 │ TApplication │
      ╚═════════╝                 └──────────────┘

         TDialog - это потомок TWindow со следующими свойствами:
         - GrowMode - 0, т.е. диалоговые окна не увеличиваются.
         - Флаги wfMove и wfClose установлены, т.е. диалоговые окна
         можно перемещать  и  закрывать  (предоставлена закрывающая
         кнопка).
         - Обработчик  событий TDialog вызывает TWindow.HandleEvent
         и дополнительно обрабатывает  отклики  на  клавиши  Esc  и
         Enter. Клавиша  Esc  генерирует команду cmCancel,  а Enter
         генерирует команду cmDefault.
         - TDialog.Valid возвращает True на команду cmCancel, иначе
         вызывает TGroup.Valid.


Методы ───────────────────────────────────────────────────────────

Init     constructor Init(var Bounds: TRect; ATitle: TTitleStr);
         Создает диалоговое окно с заданным размером  и заголовком,
         вызывая TWindow.Init(Bounds, ATitle, wnNoNumber). GrowMode
         устанавливается в 0 и Flags  устанавливается  в  wfMove  +
         wfClose. Это  означает,  что  по умолчанию диалоговые окна
         можно  перемещать  и  закрывать,  но  нельзя  изменять  их
         размеры.
         Заметим, что   TDialog    не    определяет    собственного
         дестрактора, а использует Close и Done,  наследуемые через
         TWindow, TGroup и TView.

         См. так же: TWindow.Init

HandleEvent procedure HandleEvent(var Event: TEvent); virtual;
                                              Перекрывается: Иногда
         Вызывает TWindow.HandleEvent(Event),  затем   обрабатывает
         клавиши Enter  и  Esc.  В частности Esc генерирует команду
         cmCancel, а Enter посылает общие сообщения cmDeafult. Этот
         метод  так же обрабатывает cmOK,  cmCancel,  cmYes и cmNo,
         заканчивая модальное  состояние  диалогового   окна.   Для
         каждого из  успешно обработанных событий он вызывает метод
         ClearEvent.

         См. так же: TWindow.HandleEvent

GetPalette function GetPalette: PPalette; virtual;
                                               Перекрывается: Редко
         Этот метод возвращает указатель на  палитру  по  умолчанию
         CPalette.

Valid function Valid(Command: Word): Boolean; virtual;
                                               Перекрывается: Редко
         Возвращает True,  если  заданная  команда - cmCancel,  или
         если все элементы управления группы возвращают True.

         См. так же: TGroup.Valid


 Палитра───────────────────────────────────────────────────────────

         Объекты диалогового  окна  используют палитру по умолчанию
         CDialog для отображения с  32  по  63  элемент  в  палитру
         программы.

               1   2   3   4   5   6   7   8   9
             ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
CDialog      ║ 32│ 33│ 34│ 35│ 36│ 37│ 38│ 39│ 40║
             ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
Пассивная    ──┘   │   │   │   │   │   │   │   └─ Короткая метка
рамка              │   │   │   │   │   │   │
Активная     ──────┘   │   │   │   │   │   └───── Подсвеченная
рамка                  │   │   │   │   │          метка
Кнопка     ────────────┘   │   │   │   └───────── Нормальная метка
рамки                      │   │   │
Страница       ────────────┘   │   └───────────── Статический текст
скроллинга                     │
Элементы управления ───────────┘
скроллинга



               10  11  12  13  14  15  16  17  18
             ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
CDialog      ║ 41│ 42│ 43│ 44│ 45│ 46│ 47│ 48│ 49║
             ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
Нормальная    ─┘   │   │   │   │   │   │   │   └─ Короткий кластер
кнопка             │   │   │   │   │   │   │
Кнопка по      ────┘   │   │   │   │   │   └───── Выбранный кластер
умолчанию              │   │   │   │   │
Выбранная       ───────┘   │   │   │   └───────── Нормальный
кнопка                     │   │   │              кластер
Запрещенная     ───────────┘   │   └───────────── Тень кнопки
кнопка                         │
Короткая кнопка ───────────────┘


                19  20  21  22  23  24  25
              ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╗
CDialog       ║ 50│ 51│ 52│ 53│ 54│ 55│ 56║
              ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
Нормальная    ──┘   │   │   │   │   │   └── Элементы управления
строка ввода        │   │   │   │   │       окна истории
Выбранная    ───────┘   │   │   │   │
строка ввода            │   │   │   │
Стрелки    ─────────────┘   │   │   └────── Страница окна истории
строки ввода                │   │
Стрелка истории ────────────┘   │
                                └────────── Стороны истории


                   26  27  28  29  30  31  32
                 ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╗
CDialog          ║ 57│ 58│ 58│ 59│ 60│ 61│ 62║
                 ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
Нормальный просмотр┘   │   │   │   │   │   └── Зарезервировано
списка                 │   │   │   │   │
Активный просмотр  ────┘   │   │   │   └────── Зарезервировано
списка                     │   │   │
Выбранный просмотр  ───────┘   │   └───────── Информационная панель
                               │
Разделитель просмотра ─────────┘


         См. так же: Метод GetPalette для каждого типа объекта.


DosStream                                                   Objects
═══════════════════════════════════════════════════════════════════

                  ┌────────────┐
                  │  TObject   │
                  └─────┬──────┘
                  ┌─────┴──────┐
                  │  TStream   │
                  └─────┬──────┘
                  ╔═════╧══════╗
                  ║ TDosStream ║
                  ╚═════╤══════╝
                  ┌─────┴──────┐
                  │ TBufStream │
                  └────────────┘

         TDosStream -  это специализированный TStream,  реализующий
         небуферизованный поток файла  DOS.  Констрактор  позволяет
         Вам создать  или  открыть файл DOS,  задав его имя и режим
         доступа: stCreate,  stOpenRead,  stOpenWrite  или  stOpen.
         Добавляется поле  Handle  - обработчик традиционного файла
         DOS, используемый   для   доступа   к   открытому   файлу.
         Большинство  программ  будут  использовать  буферизованный
         поток TBufStream,  порожденный от  TDosStream.  TDosStream
         перекрывает все абстрактные методы TStream, за исключением
         TStream.Flush.


Поля ─────────────────────────────────────────────────────────────

Handle: Word;                                        Только чтение
         Handle - это обработчик файла DOS используемый  только для
         доступа к открытому файлу потока.

Методы ───────────────────────────────────────────────────────────

Init     constructor Init(FileName: FNameStr; Mode: Word);
         Создает поток файла  DOS  с  именем  FileName  и  заданным
         режимом доступа. Если успешно, поле Handle устанавливается
         в обработчик файла DOS. Ошибка указывается вызовом Error с
         аргументом stInitError.
         Аргумент Mode должен принимать одно из значений: stCreate,
         stOpenRead, stOpenWrite    или   stOpen.   Эти   константы
         объяснены в "Константы потока stXXXX" главы 14.

Done     destructor Done; virtual;           Перекрывается: Никогда
         Закрывает и освобождает поток файла DOS

         См. так же: TDosStream.Init

GetPos function GetPos: Longint; virtual;    Перекрывается: Никогда
         Возвращает значение текущей позиции в потоке.

         См. так же: TDosStream.Seek

GetSize  function GetSize: Longint; virtual; Перекрывается: Никогда
         Возвращает размер потока в байтах.

Read     procedure Read(var Buf; Count: Word); virtual;
                                             Перекрывается: Никогда
         Читает Count  байт в буфер Buf,  начиная с текущей позиции
         потока.

         См. так же: TDosStream.Write, stReadError

Seek     procedure Seek(Pos: Longint); virtual;
                                             Перекрывается: Никогда
         Устанавливает текущую позицию в Pos байт от начала потока.

         См. так же: TDosStream.GetPos, TDosStream.GetSize

Truncate procedure Truncate; virtual;        Перекрывается: Никогда
         Удаляет все  данные  текущего потока от текущей позиции до
         конца потока.

         См. так же: TDosStream.GetPos, TDosStream.Seek

Write    procedure Write(var Buf; Count: Word); virtual;
         Пишет Count байт из буфера Buf в поток,  начиная с текущей
         позиции.

         См. так же: TDosStream.Read, stWriteError


TEmsStream                                                  Objects
═══════════════════════════════════════════════════════════════════

                  ┌────────────┐
                  │  TObject   │
                  └─────┬──────┘
                  ┌─────┴──────┐
                  │  TStream   │
                  └─────┬──────┘
                  ╔═════╧══════╗
                  ║ TEmsStream ║
                  ╚════════════╝

         TEmsStream -  это  специализированный  поток,  реализующий
         поток в Ems памяти, порожденный от TStream. Дополнительные
         поля представляют обработчик EMS,  число  страниц,  размер
         потока и   текущую   позицию.   TStreamEms  перекрывает  6
         абстрактных методов  TStream,  а  так   же   предоставляет
         специальный констрактор и дестрактор.

         Примечание: При   отладке   программы,   использующей  EMS
         потоки, IDE   не   может    восстановить    EMS    память,
         распределенную Вашей   программой,   если  Ваша  программа
         преждевременно завершилась,   или   Вы   забыли    вызвать
         дестрактор Done  для  EMS  потока.  Только метод Done (или
         перезагрузка) могут     освободить      EMS      страницы,
         принадлежавшие потоку.

Поля ─────────────────────────────────────────────────────────────

Handle   Handle: Word;                               Только чтение
         Обработчик EMS для потока.

PageCount PageCount: Word;                           Только чтение
         Число распределенных   для   потока  страниц,  по  16К  на
         страницу.

Size     Size: Longint;                              Только чтение
         Размер потока в байтах.

Position Position: Longint;                          Только чтение
         Текущая позиция внутри потока. Первая позиция - 0.


Методы ───────────────────────────────────────────────────────────

Init     constructor Init(MinSize: Longint);
         Создает EMS  поток  с  заданным  минимальным  размером   в
         байтах. Вызывает TStream.Init, затем устанавливает Handle,
         Size и PageCount. Вызывает Error с аргументом stInitError,
         если инициализиция неудачна.

         См. так же: TEmsStream.Done

Done     destructor Done; virtual;           Перекрывается: Никогда
         Освобождает EMS поток и используемые EMS страницы.

         См. так же: TEmsStream.Init

GetPos   function GetPos: Longint; virtual;  Перекрывается: Никогда
         Возвращает значение текущей позиции в потоке.

         См. так же: TEmsStream.Seek

GetSize  function GetSize: Longint; virtual; Перекрывается: Никогда
         Возвращает общий размер потока.

Read     procedure Read(var Buf; Count: Word); virtual;
                                             Перекрывается: Никогда
         Читает Count байт из буфера Buf, начиная с текущей позиции
         в потоке.

         См. так же: TEmsStream.Write, stReadError

Seek     procedure Seek(Pos: Longint); virtual;
                                             Перекрывается: Никогда
         Устанавливает текущую позицию в Pos байт от начала потока.

         См. так же: TEmsStream.GetPos, TEmsStream.GetSize

Truncate procedure Truncate; virtual;        Перекрывается: Никогда
         Удаляет все данные в потоке,  начиная с текущей позиции до
         конца потока.  Текущая  позиция  устанавливается  в  новый
         конец потока.

         См. так же: TDosStream.GetPos, TDosStream.Seek

Write    procedure Write(var Buf; Count: Word); virtual;
                                             Перекрывается: Никогда
         Записывает Count байт из буфера Buf  в  поток,  начиная  с
         текущей позиции.

         См. так    же:     TDosStream.Read,     TEmsStream.GetPos,
         TEmsStream.Seek


TFrame                                                        Views
═══════════════════════════════════════════════════════════════════

                   ┌─────────┐
                   │ TObject │
                   └────┬────┘
                   ┌────┴────┐
                   │  TView  │
                   └────┬────┘
                   ╔════╧════╗
                   ║ TFrame  ║
                   ╚═════════╝

         TFrame предоставляет   различные   рамки   вокруг  окон  и
         диалоговых окон.  Вероятно пользователи никогда  не  будут
         использовать объекты рамок напрямую,  т.к. они добавляются
         к окнам по умолчанию.

Методы ───────────────────────────────────────────────────────────

Init     constructor Init(var Bounds: TRect);
         Вызывает TView.Init,   затем   устанавливает   GrowMode  в
         gfGrowHiX +  gfGrowHiY   и   устанавливает   EventMask   в
         EventMask  or  evBroadcast,   так,  чтобы  объекты  TFrame
         обрабатывали по умолчанию общие события.

         См. так же: TView.Init

Draw     procedure Draw; virtual;              Перекрывается: Редко
         Рисует рамку    с    цветом    атрибутов    и    кнопками,
         соответствующими текущим    флагам    State:     активный,
         неактивный и   перемещаемый.  Добавляет  кнопки  изменения
         размера, закрытия и масштабирования в зависимости от Flags
         окна - владельца.  Добавляет заголовок, если есть, из поля
         Title окна-владельца.  Активные окна  рисуются  с  двойной
         рамкой и кнопками,  а неактивные окна с одинарной рамкой и
         без кнопок.

         См. так  же:  константы  флагов  состояния  sfXXXX,
         константы флагов окна wfXХXX

GetPalette function GetPalette: Palette; virtual;
                                               Перекрывается: Редко
         Возвращает указатель на палитру рамки по умолчанию CFrame.

HandleEvent procedure HandleEvent(var Event: TEvent); virtual;
                                               Перекрывается: Редко
         Вызывает TView.HandleEvent,  затем обрабатывает события от
         мышки. Если закрывающая  кнопка  отмечена  мышкой,  TFrame
         генерирует события cmClose. Отметка кнопки масштабирования
         или двойная отметка верхней линии рамки генерирует событие
         cmZoom. При  перемещении  мышкой  за  верхнюю строку рамки
         окно перемещается,  а  перемещение  за  кнопку   изменения
         размера передвигает   нижний   правый   угол   элемента  и
         соответственно изменяет его размер.

         См. так же: TView.HandleEvent

SetState procedure SetState(AState: Word; Enable: Boolean);
                            virtual;           Перекрывается: Редко
         Вызывает TView.SetState,  затем,  если новое  состояние  -
         sfActive или sfDragging, вызывает DrawView для перерисовки
         видимого элемента.

         См. так же: TView.SetState


 Палитра───────────────────────────────────────────────────────────

         Объекты рамок  используют  палитру по умолчанию CFrame для
         отображения первых трех элементов в  палитру  стандартного
         окна.

                   1   2   3   4   5
                 ╔═══╤═══╤═══╤═══╤═══╗
   CFrame        ║ 57│ 58│ 58│ 61│ 62║
                 ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
   Пассивная ──────┘   │   │   │   └── Кнопки
   рамка               │   │   │
   Пассивный ──────────┘   │   └────── Активный заголовок
   заголовок               │
   Активная ───────────────┘
   рамка


TGroup                                                        Views
═══════════════════════════════════════════════════════════════════

                    ┌─────────┐
                    │ TObject │
                    └────┬────┘
                    ┌────┴────┐
                    │  TView  │
                    └────┬────┘
                    ╔════╧════╗
                    ║ TGroup  ║
                    ╚═╤══╤══╤═╝
           ┌──────────┘  │  └────────────┐
      ┌────┴────┐   ┌────┴─────┐  ┌──────┴───────┐
      │ TWindow │   │ TDeskTop │  │ TProgram     │
      └────┬────┘   └──────────┘  └──────┬───────┘
      ┌────┴────┐                 ┌──────┴───────┐
      │ TDialog │                 │ TApplication │
      └─────────┘                 └──────────────┘

         Объекты TGroup и их порождения (которые мы  для  краткости
         называем группами)   -  основная  управляющая  сила  Turbo
         Vision. Группы - это   специальные   порождения    видимых
         элементов. В   дополнение   ко   всем   полям  и  методам,
         порожденным от TView,  группа имеет дополнительные поля  и
         методы (включая   перекрывающие),   позволяющие  управлять
         динамически связанными списками видимых элементов (включая
         другие группы) как  одним  объектом.  Мы  часто говорили о
         подэлементах группы  даже  если   эти   подэлементы   сами
         являются группами.
         Хотя группа имеет прямоугольную границу от  своего  предка
         TView, группа   видима   только  через  отображение  своих
         подэлементов. Концептуально  группа  рисует   себя   через
         методы Draw  своих  подэлементов.  Группа  владеет  своими
         подэлементами и   они   должны   обеспечивать    зарисовку
         (заполнение) всего прямоугольника группы Bounds.  Во время
         работы программы  подэлементы   и   подгруппы   создаются,
         вставляются в   группы   и   отображаются   в   результате
         деятельности пользователя    и    событий,    генерируемых
         программой.  Подэлементы могут быть легко скрыты,  удалены
         из группы действиями  пользователя  (такими  как  закрытие
         окна или выход из диалогового окна).
         3 порожденных  от  TGroup   типа:  TWindow,   TDeskTop   и
         TApplication (через TProgram) иллюстрируют концепцию групп
         и подгрупп.   TApplication   обычно   владеет    объектами
         TDeskTop, TStatusLine  и  TMenuView.  TDeskTop порожден от
         TGroup и таким образом может  владеть  объектами  TWindow,
         которые в   свою   очередь   владеют   объектами   TFrame,
         TScrollBar и т.д.
         Объекты TGroup  передают  рисование  и  обработку  событий
         своим подэлементам, как объясняется в главах 4 и 5.
         Многие из  основных  методов TView перекрываются в TGroup.
         Например, сохранение и чтение группы из потока  может быть
         достигнуто одним вызовом TGroup.Store и TGroup.Load.
         Объекты TGroup обычно  не  имеют  экземпляров;  Вы  будете
         создавать экземпляры  от  типов  объектов,  порожденных от
         TGroup: TApplication, TDeskTop и TWindow.

Поля ─────────────────────────────────────────────────────────────

Last     Last : PView;                               Только чтение
         Указывает на последний подэлемент группы (самый дальний от
         вершины в Z-порядке).  Поле  Next  последнего  подэлемента
         указывает на первый подэлемент, чье поле Next указывает на
         следующий подэлемент и т.д. формируя циклический список.

Current  Current: PView;                             Только чтение
         Указывает на выбранный подэлемент или равен nil,  если нет
         выбранного подэлемента.

         См. так же: sfSelected, TView.Select

Buffer   Buffer: PVideoBuf;                          Только чтение
         Указывает на буфер,  используемый для кэширования операций
         перерисовки или  равен   nil,   если   группа   не   имеет
         кэш-буфера. Кэш-буфера     создаются     и    уничтожаются
         автоматически, если флаг  ofBuffered  в  поле  Options  не
         очищен.

         См. так же: TGroup.Draw, TGroup.Lock, TGroup.Unlock

Phase    Phase: (phFocused, phPreProcess, phPostProcess);
                                                     Только чтение
         Текущая фаза обработки для активного события. Подэлементы,
         в которых    установлены    флаги    ofPreProcess    и/или
         ofPostProcess могут    проверять    Owner^.Phase,    чтобы
         определить, в какой из  фаз  phPreProcess,  phFocused  или
         phPostProcess был вызван их HandleEvent.

         См. так       же:       ofPreProcess,       ofPostProcess,
         TGroup.HandleEvent


Методы ───────────────────────────────────────────────────────────

Init     constructor Init(var Bounds: TRect);
         Вызывает TView.Init,  устанавливает в Options ofSelectable
         и ofBuffered и устанавливает EventMask в $FFFF.

         См. так же: TView.Init, TGroup.Load

Load     constructor Load(var S: TStream);
         Загружает всю   группу   из   потока,   вызывая    вначале
         наследуемый TView.Load,  а затем используя TStream.Get для
         чтения каждого   подэлемента.    После    загрузки    всех
         подэлементов выполняет    проход   по   подэлементам   для
         установки всех  считанных  указателей   с   использованием
         GetPeerViewPtr.
         Если тип объекта,  порожденного от TGroup  содержит  поля,
         которые указывают  на подэлементы,  он должен использовать
         GetSubViewPtr внутри Load, чтобы читать эти поля.

         См. так же: TView.Load, TGroup.Store, TGroup.GetSubViewPtr

Done     destructor Done; virtual;             Перекрывается: Часто
         Перекрывает TView.Done.  Скрывает группу,  используя Hide,
         освобождает каждый элемент  группы,  используя  Dispose(P,
         Done) и наконец вызывает наследуемый TView.Done.

         См. так же: TView.Done

ChangeBounds procedure ChangeBounds(var Bounds: Trect); virtual;
                                             Перекрывается: Никогда
         Перекрывает TView.ChangeBounds.  Изменяет границы группы в
         Bounds, затем  вызывает  CalcBounds  и  ChangeBounds   для
         каждого элемента группы.

         См. так же: TView.CalcBounds, TView.ChangeBounds

DataSize function DataSize: Word; virtual;     Перекрывается: Редко
         Перекрывает TView.DataSize.   Возвращает   общий    размер
         группы, вызывая   и   накапливая   DataSize   для  каждого
         подэлемента.

         См. так же: TView.DataSize

Delete   procedure Delete(P: PView);
         Удаляет подэлемент  P  из  группы  и перерисовывает другие
         подэлементы, если  необходимо.  Поля  Owner  и  Next  в  Р
         устанавливаются в nil.

         См. так же: TGroup.Insert

Draw     procedure Draw; virtual;            Перекрывается: Никогда
         Перекрывает TView.Draw.  Если  кэш-буфер  существует  (см.
         поле TGroup.Buffer),   то   буфер   пишется   на  экран  с
         использованием TView.WriteBuf.  Иначе  каждый   подэлемент
         рисует себя с помощью TGroup.Redraw.

         См. так же: TGroup.Buffer, TGroup.Redraw

EndModal procedure EndModal(Command: Word); virtual;
                                             Перекрывается: Никогда
         Если группа  -  это  текущий  модальный  видимый  элемент,
         модальное состояние   завершается.  Command  передается  в
         ExecView, который возвращает Command как  результат.  Если
         эта  группа  не  текущий  модальный  видимый элемент,  она
         вызывает TView.EndModal.

         См. так же: TGroup.ExecView, TGroup.Execute

EventError procedure EventError(var Event: TEvent); virtual;
                                              Перекрывается: Иногда
         EventError вызывается  когда  в  цикле обработчика события
         модального TGroup.Execute встречается событие,  которое не
         может быть обработано.  Действие по умолчанию:  Если Owner
         группы не  nil,  EventError  вызывает  EventError   своего
         владельца. Обычно    эта   цепочка   распространяется   до
         EventError из TApplication. Вы можете перекрыть EventErrоr
         для выполнения требуемого действия.

         См. так же: TGroup.Execute, TGroup.ExecView, sfModal

ExecView function ExecView(P: PView): Word;
         ExecView -  это  модальный  вариант  немодальных   методов
         Insert  и  Delete.  В  отличие  от  Insert  после  вставки
         видимого  элемента  в  группу  ExecView  ожидает   видимый
         элемент  для  выполнения,  затем удаляет видимый элемент и
         возвращает результат выполнения.  ExecView используется  в
         ряде   мест   в  Turbo  Vision,  например  для  реализации
         TApplication.Run и  для  выполнения  модальных  диалоговых
         окон.
         ExecView сохраняет  текущий  контекст  (выбранный  видимый
         элемент, модальный  видимый элемент и набор команд) делает
         Р модальным, вызывая Р^.SetState(sfModal, True), вставляет
         Р в   группу   (если   он  еще  не  вставлен)  и  вызывает
         P^.Execute. Когда P^.Execute возвращает управление, группа
         восстанавливается в   предыдущее   состояние  и  результат
         P^.Execute возвращается  как  результат  вызова  ExecView.
         Если P  -  nil  в  вызове ExecView,  возвращается значение
         cmCancel.

         См. так же: TGroup.Execute, sfModal

Execute  function Execute: Word; virtual;      Перекрывается: Редко
         Перекрывает TView.Execute.  Execute  -  это  главный  цикл
         событий группы:  она постоянно получает события, используя
         GetEvent и  обрабатывает  их, используя HandleEvent.  Цикл
         событий завершается группой  или  подэлементом  с  помощью
         вызова EndModal.  Однако  до  возврата Exec вызывает Valid
         для проверки,  что модальное состояние в самом  деле  было
         завершено.
         Реализация  TGroup.Execute  показана  ниже.  Заметим,  что
         EndState -    это   private   поле   в   TGroup,   которое
         устанавливается вызовом EndModel.

         function TGroup.Execute: Word;
         var
           E: TEvent;
         begin
           repeat
             EndState := 0;
             repeat
               GetEvent(E);
               HandleEvent(E);
               if E.What <> evNothing then EventError(E);
             until EndState <> 0;
           until Valid(EndState);
           Execute := EndState;
         end;

         См. так же:    TGroup.GetEvent, TGroup.HandleEvent,
                        TGroup.EndModal, TGroup.Valid

First    function First: PView;
         Возвращает указатель  на  первый  подэлемент  (ближайший к
         вершине в  Z-порядке),  или  nil,  если   в   группе   нет
         подэлементов.

         См. так же: TGroup.Last

FirstThat function FirstThat(Test: Pointer): PView;
         FirstThat применяет булевскую функцию, заданную указателем
         на функцию  Test  к каждому подэлементу в Z-порядке до тех
         пор, пока Test не вернет True.  Результат -  указатель  на
         подэлемент, для  которог  Test  возвращает True,  или nil,
         если функция Test возвращает False для  всех подэлементов.
         Test должна    указывать    дальнюю   локальную   функцию,
         использующую параметр типа Pointer и возвращающую значение
         типа Boolean. Например:

         function MyTestFunc(P: PView): Boolean; far;

         Метод SubViewAt, показанный ниже,  возвращает указатель на
         первый подэлемент, содержащий данную точку.

         function TMyGroup.SubViewAt(Where: TPoint): PView;

           function ContainsPoint(P: PView): Boolean; far;
           var
             Bounds: TRect;
           begin
             P^.GetBounds(Bounds);
             ContainsPoint := (P^.State and sfVisible <> 0) and
               Bounds.Contains(Where);
           end;

         begin
           SubViewAt := FirstThat(@ContainsPoint);
         end;

         См. так же: TGroup.ForEach

ForEach  procedure ForEach(Action: Pointer);
         ForEach выполняет действие,  заданное указателем Action на
         процедуру к каждому подэлементу группы в Z-порядке. Action
         должна указывать   на   дальнюю    локальную    процедуру,
         использующую параметр типа Pointer, например:

         procedure MyActionProc(P: PView); far;

         Метод MoveSubViews  перемещает  все  подэлементы группы на
         значение, заданное в Delta.  Заметим использование Lock  и
         UnLock для   ограничения  числа  выполняемых  операций  по
         перерисовке для предотвращения неприятного мерцания.

         procedure TMyGroup.MoveSubViews(Delta: TPoint);

           procedure DoMoveView(P: PView); far;
           begin
             P^.MoveTo(P^.Origin.X + Delta.X, P^.Origin.Y + Delta.Y);
           end;

         begin
           Lock;
           ForEach(@DoMoveView);
           UnLock;
         end;

         См. так же: TGroup.FirstThat

GetData  procedure GetData(var Rec); virtual;  Перекрывается: Редко
         Перекрывает TView.GetData.  Вызывает GetData  для  каждого
         подэлемента в  Z-порядке увеличивая положение,  заданное в
         Rec на DataSize для каждого подэлемента.

         См. так же: TView.GetData, TGroup.SetData

GetHelpCtx function GetHelpCtx: Word; virtual; Перекрывается: Редко
         Возвращает контекст   подсказки   для  текущего  активного
         видимого элемента,  вызывая метод  выбранного  подэлемента
         GetHelpCtx. Если   нет   контекста   подсказки,  заданного
         подэлементом, GetHelpCtx возвращает  значение собственного
         поля HelpCtx.

GetSubViewPtr procedure GetSubViewPtr(var S: TStream; var P);
         Загружает указатель  на  подэлемент   Р   из   потока   S.
         GetSubViewPtr должна    использоваться    только    внутри
         констрактора Load для чтения значений  указателей, которые
         были записаны вызовом PutSubViewPtr из метода Store.

         См. так же: TView.PutSubViewPtr, TGroup.Load, TGroup.Store

HandleEvent procedure HandleEvent(var Event: TEvent); virtual;
                                               Перекрывается: Часто
         Перекрывает TView.HandleEvent.     Группа     обрабатывает
         события, передавая их  в  методы  HandleEvent  одного  или
         более подэлементов.  Однако действительный маршрут зависит
         от класса события.
         Для активных  событий (по умолчанию evKeyDown и evCommand,
         см. переменную    FocusedEvents)     обработка     событий
         выполняется в    3    фазы:    во-первых,    поле    Phase
         устанавливается в  phPreProcess  и  событие  передается  в
         HandleEvent всех  подэлементов,  в которых установлен флаг
         ofPreProcess. Затем Phase устанавливается  в  phFocused  и
         событие передается   в   HandleEvent  текущего  выбранного
         видимого элемента.  Наконец,   Phase   устанавливается   в
         phPostProcess и  событие  передается  в  HandleEvent  всех
         подэлементов, в которых установлен флаг ofPostProcess.
         Для позиционированных  событий (по умолчанию evMouse,  см.
         переменную PositionalEvents),   событие    передается    в
         HandleEvent первого    подэлемента,   чей   ограничивающий
         прямоугольник содержит точку, заданную в Event.Where.
         Для общих    событий    (т.е.    не    активных    и    не
         позиционированных), событие   передается   в   HandleEvent
         каждого подэлемента группы в Z-порядке.

         Примечание: Если   поле  EventMask  подэлемента  маскирует
         класс события,   TGroup.HandleEvent   никогда   не   будет
         посылать события  этого класса подэлементу.  Например,  по
         умолчанию EventMask   из   TView   запрещает    evMouseUp,
         evMouseMove и   evMouseAuto,   поэтому  TGroup.HandleEvent
         никогда не  будет  посылать  такие  события   стандартному
         TView.

         См. так  же:  FocusedEvents,  PositionalEvents,  константы
         событий evXXXX, TView.EventMask, методы HandleEvent

Insert   procedure Insert(P: PView);
         Вставляет видимый    элемент,    заданный   Р   в   список
         подэлементов группы. Новый подэлемент помещается над всеми
         другими видимыми   подэлементами.   Если   в   подэлементе
         установлены флаги   ofCenterX    и/или    ofCenterY,    он
         центрируется  в   группе   соответственно.   Если  видимый
         элемент имеет  установленный  флаг  sfVisible,  он   будет
         показан в  группе  -  иначе остается невидимым до тех пор,
         пока не будет показан  специально.  Если  видимый  элемент
         имеет установленным   флаг   ofSelectable,  он  становится
         текущим выбранным подэлементом.

InsertBefore procedure InsertBefore(P, Target: PView);
         Вставляет видимый   элемент,  заданный  Р,  перед  видимым
         элементом, заданным  Target.  Если  Target  nil,   видимый
         элемент размещается после всех видимых элементов группы.

         См. так же: TGrouup.Unsert, TGroup.Delete

Lock     procedure Lock;
         Блокирует группу,  задерживая  все  записи,   производимые
         подэлементами на  экран  до тех пор,  пока группа не будет
         разблокирована. Lock не имеет эффекта,  если в группе  нет
         кэш-буфера (см.    ofBuffered   и   TGroup.Buffer).   Lock
         работает, увеличивая    счетчик    блокировок,     который
         соответственно уменьшается  с помощью UnLock.  Когда вызов
         UnLock уменьшает счетчик  до  0,  вся  группа  пишется  на
         экран, используя образ, созданный в кэш-буфере.
         Накапливая интенсивные операции прорисовки  между вызовами
         Lock и UnLock, можно сократить или полностью избавиться от
         неприятного мерцания  экрана.  Например,  TDeskTop.Tile  и
         TDeskTop.Cascade используют  Lock  и UnLock для сокращения
         мерцания.

         Примечание: Вызовы   Lock    и    UnLock    должны    быть
         сбалансированы, иначе  группа  может  остаться в постоянно
         заблокированном состоянии, что приведет к тому, что она не
         сможет вывести себя при необходимости.

         См. так же: TGroup.Unlock

PutSubViewPtr procedure PutSubViewPtr(var S: TStream; P: PView);
         Сохраняет указатель   подэлемента   Р    в    потоке    S.
         PutSubViewPtr должна  использоваться  только внутри метода
         Store для записи значений указателей,  которые позже будут
         читаться вызовами GetSubViewPtr в констракторе Load.

         См. так    же:     TGroup.GetSubViewPtr,     TGroup.Store,
         TGroup.Load

Redraw   procedure Redraw;
         Перерисовывает подэлементы     группы     в     Z-порядке.
         TGroup.Redraw отличается   от   TGroup.Draw    тем,    что
         перерисовка никогда не производится выводом из кэш-буфера.

         См. так же: TGroup.Draw

SelectNext procedure SelectNext(Forwards: Boolean);
         Если Forwards - True,  SelectNext будет  выбирать  (делать
         текущим) следующий  выбираемый  подэлемент (подэлемент,  в
         котором установлен бит ofSelectable) группы  в  Z-порядке.
         Если Forwards   -   False,   метод   выбирает   предыдущий
         выбираемый элемент.

         См. так же: константы флагов опций ofXXXX

SetData  procedure  SetData(var Rec); virtual; Перекрывается: Редко
         Перекрывает TView.SetData.  Вызывает  SetData  для каждого
         подэлемента в  порядке,  обратном  Z-порядку,   увеличивая
         положение, заданное   в   Rec,  на  DataSize  для  каждого
         подэлемента.

         См. так же: TGroup.GetData, TView.SetData

SetState procedure SetState(AState: Word; Enable: Boolean);virtual;
                                               Перекрывается: Редко
         Перекрывает TView.SetState.        Вначале        вызывает
         унаследованный TView.State,  затем  обновляет  подэлементы
         следующим образом:
         Если AState - sfActive, sfExposed или sfDragging, SetState
         вызывается для каждого подэлемента для его обновления.
         Если AState  - sfFocused,  то вызывается текущий выбранный
         подэлемент для своей активизации.

         См. так же: TView.SetState

Store    procedure Store(var S: TStream);
         Сохраняет всю    группу    в    потоке   вначале   вызывая
         унаследованный TView.Store,  затем  используя  TStream.Put
         для вывода каждого подэлемента.
         Если объектный тип,  порожденный от TGroup, содержит поля,
         которые указывают  на подэлементы,  он должен использовать
         PutSubViewPtr внутри его Store для записи этих полей.

         См. так же: TView.Store, TGroup.PutSubViewPtr, TGroup.Load

Unlock   procedure Unlock;
         Разблокирует группу,  уменьшая  счетчик  блокировки.  Если
         счетчик блокировки становится 0,  то вся группа  выводится
         на экран, используя образ, созданный в кэш-буфере.

         См. так же: TGroup.Lock

Valid    function Valid(Command: Word): Boolean; virtual;
         Перекрывает TView.Valid.  Возвращает  True,  если   вызовы
         Valid всех   подэлементов  возвращают  True.  TGroup.Valid
         используется  в   конце   цикла   обработки   событий    в
         TGroup.Execute для     подтверждения,    что    завершение
         разрешено. Модальное состояние не может быть  завершено до
         тех пор,  пока все вызовы Valid не вернут True. Подэлемент
         может вернуть  False,  если  он  хочет,  чтобы  управление
         осталось у него.

         См. так же: TView.Valid, TGroup.Execute


THistory                                                    Dialogs
═══════════════════════════════════════════════════════════════════

                  ┌──────────┐
                  │ TObject  │
                  └────┬─────┘
                  ┌────┴─────┐
                  │  TView   │
                  └────┬─────┘
                  ╔════╧═════╗
                  ║ THistory ║
                  ╚══════════╝

         Объект THistory реализует список  для  отметки  предыдущих
         значений, действий    или    выборов.   Объекты   THistory
         связываютя с объектом TInputLine  и  со  списком  истории.
         Информация списка  истории  хранится  в блоке памяти кучи.
         Когда блок заполняется,  наиболее старые элементы  истории
         удаляются, а новые добавляются.
         Объект THistory показан как кнопка (|∙|)  в  конце  строки
         ввода. Когда  пользователь отмечает кнопку истории,  Turbo
         Vision открывает окно истории  (смотри  THistoryWindow)  с
         просмотром истории   (смотри  THistoryViewer),  содержащем
         список предыдущих элементов.
         Различные строки  ввода  могут  использовать  один  список
         истории, используя одинаковый номер ID.


Поля ─────────────────────────────────────────────────────────────

 Link: PInputLine;                                   Только чтение
         Указатель на связанный объект TInputLine.


 HistoryID HistoryID: Word;                          Только чтение
         Каждый список   истории   имеет   уникальный   номер   ID,
         назначаемый программистом.  Различные  объекты  историй  в
         различных окнах могут разделять список  истории, используя
         одинаковый ID номер.


Методы ───────────────────────────────────────────────────────────

 Init    constructor  Init(var  Bounds: TRect;  ALink: PInputLine;
                        AHistoryID: Word);
         Создает объект   THistоry   заданного   размера,   вызывая
         TView.Init, затем  устанавливает  поля  Link  и  HistoryId
         значениями, заданными   в   аргументах.    Поле    Options
         устанавливатся в ofPostProcess, а EventMask в evBroadcast.

         См. так же: TView.Init

 Load    constructor Load(var S: TStream);
         Создает и  инициализирует  объект  History   из   TStream,
         вызывая  TView.Load(S) и читая Link и HistoryId из S.

         См. так же: TView.Store

 Draw    procedure Draw; virtual;              Перекрывается: Редко
         Рисует кнопку History в палитре по умолчанию.

 GetPalette function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель на умалчиваемую палитру CHistory.

 Store   procedure Store(var S:TStream);
         Сохраняет объект     THistory     в    TStream,    вызывая
         TView.Store(S), затем записывает Link и HistoryId в S.

         См. так же: TView.Load


Палитра───────────────────────────────────────────────────────────

         Кнопки истории  используют  палитру  по умолчанию CHistory
         для отображения   14   и   20-го   элементов   в   палитру
         стандартного диалогового окна.


                         1    2
                      ╔════╤════╗
         CHistory     ║ 14 │ 20 ║
                      ╚══╤═╧═╤══╝
         Стрелка ────────┘   └─────── Стороны


THistoryViewer                                              Dialogs
═══════════════════════════════════════════════════════════════════

         THistoryViewer -   прямой    потомок    TListViewer.    Он
         используется системой  списка  истории и появляется внутри
         окна истории при отметке кнопки  истории.  Для  детального
         описания взаимодействия    THistory,    THistoryWindow   и
         THistoryViewer смотри  THistory в этой главе.


Поля ─────────────────────────────────────────────────────────────

 HistoryID  HistoryID: Word;                         Только чтение
         HistoryId - это ID номер списка истории,  отображаемого  в
         этом видимом элементе.


Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(var Bounds:TRect;
           AHScrollBar, AVScrollBar: PScrollBar; AHistoryID: Word);
         Init инициализирует  видимый  элемент   просмотра  списка,
         вначале вызывая  TListViewer.Init  для  установки  границ,
         одной колонки и  двух  полос  скроллинга,  передаваемых  в
         AHScrollBar и  AVScrollBar.  Видимый  элемент  связывается
         затем со   списком    истории,    с    полем    HistoryId,
         установленным в  значение,  переданное  в  AHistory.  Этот
         список проверяется затем на длину так, что диапазон списка
         устанавливается в  число  списка.  Первый элемент в списке
         истории дан   как   активный.   Диапазон   горизонтального
         скроллинга устанавливается  в соответствие с самым широким
         элементом списка.

         См. так же: TListViewer.Init

 GetPalette function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель     на      умалчиваемую      палитру
         CHistoryViewer.

 GetText  function GetText(Item: Integer; MaxLen: Integer): String;
         virtual;                              Перекрывается: Редко
         Возвращает строку Item в связанном списке истории. GetText
         вызывается виртуальным методом Draw для  каждого  видимого
         элемента в списке.

         См. так же: TListViewer.Draw, HistoryStr function

 HandleEvent procedure HandleEvent(var Event: TEvent); virtual;
                                              Перекрывается: Иногда
         Видимый элемент  просмотра  истории управляет двумя видами
         событий; все другие передаются  в TListViewer.HandleEvent.
         Двойная отметка  или нажатие клавиши Enter будут завершать
         модальное состояние окна истории с командой cmOK.
         При нажатии  клавиши  Esc или получении командного события
         cmCancel, выбор списка истории будет  отменен.

         См. так же: TListViewer.HandleEvent

 HistoryWidth function HistoryWidth: Integer;
         Возвращает длину  самой  длинной  строки в списке истории,
         связанном с HistoryId.


Палитра───────────────────────────────────────────────────────────

         Объекты просмотра  истории используют палитру по умолчанию
         CHistoryViewer для отображения в 6 и  7  элементы  палитры
         стандартного диалогового окна.


                     1   2   3   4   5
                   ╔═══╤═══╤═══╤═══╤═══╗
   CHistoryViewer  ║ 57│ 58│ 58│ 61│ 62║
                   ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
   Активный ─────────┘   │   │   │   └── Разделитель
   Неактивный ───────────┘   │   └────── Выбранный
   Сфокусированный ──────────┘


THistoryWindow                                              Dialogs
═══════════════════════════════════════════════════════════════════

         THistoryWindow -   это   специализированный  наследник  от
         TWindow, используемый   для   объекта   просмотра   списка
         истории, когда   пользователь   отмечает  кнопку  истории,
         стоящую за строкой  ввода.  По  умолчанию  окно  не  имеет
         заголовка и  номера.  Рамка окна истории имеет закрывающую
         кнопку, поэтому окно  может  быть  закрыто,  но  не  может
         изменить размер или масштабироваться.
         Для деталей по использованию  списков истории  и связанных
         с ними объектов см. THistory в этой главе.

 Поля ─────────────────────────────────────────────────────────────

 Viewer  Viewer: PListViewer;
         Viewer указывает на список просмотра окна истории.

 Методы ───────────────────────────────────────────────────────────

 Init    constructor  Init(var Bounds: TRect; HistoryId: Word);
         Вызывает TWindow.Init   для  установки  окна  с  заданными
         границами, пустой строкой  заголовка  и  без  номера  окна
         (wnNoNumber). Поле    TWindow.Flags    устанавливается   в
         wfClose, чтобы  обеспечить  закрывающую  кнопку  и  объект
         просмотра истории   создается,   чтобы  показать  элементы
         списка истории, заданные через HistoryID.

         См. так же: TWindow.Init, THistoryWindow.InitViewer

 GetPalette  function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель     на     палитру    по    умолчанию
         CHistoryWindow.

 GetSelection  function GetSelection: String; virtual;
                                             Перекрывается: Никогда
         Возвращает строковое   значение   активного   элемента  из
         просмотра истории.


         См. так же: THistoryViewer.GetText

 InitViewer  procedure InitViewer(HistoryOd: Word); virtual;
                                             Перекрывается: Никогда
         Создает и  вставляет  объект  THistoryViewer внутри границ
         окна истории  со  списком,   заданным   через   HistoryId.
         Стандартные полосы  скроллинга размещены на рамке окна для
         скольжения по списку.

         См. так же: THistoryViewer.Init

 Палитра ──────────────────────────────────────────────────────────

         Объекты окна  истории  используют  по  умолчанию   палитру
         CHistoryWindow для  отображения на элементы с 19 по 25-й в
         палитре стандартного диалогового окна.

                  1    2    3    4    5    6    7
               ╔════╤════╤════╤════╤════╤════╤════╗
CHistoryWindow ║ 10 │ 11 │ 12 │ 13 │ 14 │ 14 │ 14 ║
               ╚══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╝
Пассивная рамка ──┘    │    │    │    │    │    └── Выбранный текст
Активная рамка  ───────┘    │    │    │    │
Кнопка рамки ───────────────┘    │    │    └────── Нормальный текст
                                 │    │
                                 │    └──────── Элементы управления
                                 └───────────── Область страницы


 TInputLine                                                 Dialogs
═══════════════════════════════════════════════════════════════════

                  ┌─────────────┐
                  │  TObject    │
                  └──────┬──────┘
                  ┌──────┴──────┐
                  │   TView     │
                  └──────┬──────┘
                  ╔══════╧══════╗
                  ║  TInputLine ║
                  ╚═════════════╝

         Объект TInputLine  обеспечивает  редактор строк ввода.  Он
         управляет вводом  с  клавиатуры  и  мышки  и  перемещением
         помеченных блоков   в  различных  функциях  редактирования
         строки (см.   TInputLine.HandleEvent).   Выбранный   текст
         удаляется и  заменяется  первым  введенным  текстом.  Если
         MaxLen больше  размера  по  Х   (Size.X),   поддерживается
         горизонтальный скроллинг,  который  указывается  правой  и
         левой стрелками.
         Методы GetData и SetData предназначены для записи и чтения
         строк данных  (через поле указателя Data) в данную запись.
         TInputLine.SetState упрощает перерисовку видимого элемента
         соответствующим цветом,  когда состояние изменяется из или
         в sfActive и sfSelected.
         Строка ввода часто имеет  ассоциированные  с  ним  объекты
         TLabel и/или THistory.
         TInputLine можно  расширить  для  обработки  типов  данных
         отличных от строк.  Чтобы сделать это, Вы добавляете новые
         поля и  перекрываете  методы  Init,  Load,  Store,  Valid,
         DataSize, GetData  и SetData.  Например,  чтобы определить
         строку ввода  числа,  Вы  можете  задать   минимальное   и
         максимальные допустимые     значения,     которые    будут
         проверяться функцией Valid. Эти минимальные и максимальные
         поля будут  загружаться  и  сохраняться  в потоке методами
         Load и Store.  Valid модифицируется для проверки того, что
         значение находится   в   допустимом   диапазоне.  DataSize
         модифицируется для включения размера диапазона новых полей
         (вероятно SizeOf(Longint) для каждого).  В этом примере не
         обязательно добавлять   поле   для   хранения    числового
         значения. Оно   может  храниться  как  строковое  значение
         (которое    уже    обрабатывается    в    TInputLine)    и
         преобразовываться  из строки в числовое значение и обратно
         методами GetData и SetData соответственно.

 Поля ─────────────────────────────────────────────────────────────

 Data    Data: PString;                               Чтение/Запись
         Указатель на строку, содержащую редактируемую информацию.

 MaxLen  MaxLen: Integer;                             Только чтение
         Максимальная длина,  допустимая для строки,  включая  байт
         длины.

         См. так же: TInputLine.DataSize

 CurPos  CurPos: Integer;                             Чтение/Запись
         Индекс на точку вставки (т.е. на текущую позицию курсора).


         См. так же: TInputLine.SelectAll
 FirstPos  FirstPos: Integer;                         Чтение/Запись
         Индекс на первый отображаемый символ.

         См. так же: TInputLine.SelectAll

 SelStart  SelStat: Integer;                          Только чтение
         Индекс на начало выбранной области (т.е.  на первый символ
         отмеченного блока).

         См. так же: TInputLine.SelectAll

 SelEnd  SelEnd: Integer;                             Только чтение
         Индекс на  конец  выбранной  области  (т.е.  на  последний
         символ отмеченного блока).

         См. так же: TInputLine.SelectAll


 Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(var Bounds: TRect; AMaxLen: Integer);
         Создает прямоугольник  ввода   с   заданными   значениями,
         вызывая TInputLine.Init.     State    устанавливается    в
         sfCursorVis, Options  устанавливается  в  (ofSelectable  +
         ofFirstClick), и  MaxLen устанавливается в AMaxLen. Память
         распределяется и очищается под AMaxLen +  1  байт  и  поле
         Data устанавливается для указания этого распределения.

         См. так       же:      TView.Init,      TView.sfCursorVis,
         TView.ofSelectable, TView.ofFirstClick

 Load    constructor Load(var S: TStream);
         Создает и инициализирует объект TInputLine, вызывая TView.
         Load(S) для  загрузки  видимого элемента из потока,  затем
         читает целочисленные поля,  используя S.Read, распределяет
         MaxLen+1 байт   через   Data,   вызывая   GetMem.  Наконец
         устанавливает байт длины  строки  и  загружает  данные  из
         потока двумя   дополнительными   вызовами   S.Read.   Load
         используется совместно с TInputLine.Store для сохранения и
         восстановления объектов TInputLine из TStream.
         Перекрывайте этот  метод,  если  Вы  определили  потомков,
         содержащих дополнительные поля.

         См. так же: TView.Load, TInputLine.Store, TStream.Read

 Done    destructor Done; virtual;             Перекрывается: Редко
         Освобождает память Data,  затем  вызывает  TView.Done  для
         разрушения объекта TInputLine.

         См. так же: TView.Done

 DataSize  function DataSize: Word; virtual;  Перекрывается: Иногда
         Возвращает размер   записи   для   TInputLine.GetData    и
         TInputLine.SetData. По  умолчанию  возвращается  MaxLen+1.
         Перекройте этот метод,  если Вы  определили  потомков  для
         обработки других типов данных.

         См. так же: TInputLine.GetData, TInputLine.SetData

 Draw    procedure Draw; virtual;              Перекрывается: Редко
         Рисует прямоугольник ввода  и  его  данные.  Прямоугольник
         рисуется соответствующим цветом  в  зависимости  от  того,
         является  ли  он  sfFocused  или нет (т.е.  находится ли в
         видимом элементе курсор или нет) и стрелки  рисуются, если
         строка  ввода  превышает размер видимого элемента (в любом
         или в обоих  направлениях).  Любые  выбранные  (отмеченный
         блок) символы рисуются соответствующим цветом.

 GetData procedure GetData(var Rec); virtual; Перекрывается: Иногда
         Записывает DataSize   байт   из  строки  Data^  в  запись.
         Используется с   TInputLine.SetData   в   ряде   программ,
         например во временной памяти или при передаче строки ввода
         в другие видимые элементы.  Перекройте этот метод, если Вы
         определяете потомка   для   обработки   нестроковых  типов
         данных. Используйте этот метод  для  преобразования  Ваших
         типов данных в строку, редактируемую с помощью TInputLine.

         См. так же: TInputLine.DataSize, TInputLine.SetData

 GetPalette  function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель на палитру по умолчанию CInputLine.

 HandleEvent  procedure HandleEvent(var Event: TEvent); virtual;
                                              Перекрывается: Иногда
         Вызывает TView.HandleEvent,   которая   обрабатывает   все
         события от мышки и клавиатуры,  если  прямоугольник  ввода
         выбран. Этот    метод    реализует   стандартные   функции
         редактирования.
         Функции редактирования  включают:  отметку  блока  мышкой;
         удаление блока, вставку или перекрытие элемента управления
         с автоматическим  изменением формы курсора; автоматический
         и ручной  скроллинг (зависит  от  относительных   размеров
         строки Data  и  Size.X);  ручной  горизонтальный скроллинг
         через отметку мышкой на кнопках стрелок;  ручное  движение
         курсора с  помощью стрелок Home и End;  удаление символа и
         блока с   помощью   Del   и   Ctrl-G.   Видимый    элемент
         перерисовывается при   необходимости   и  поля  TInputLine
         соответственно изменяются.

         См. так      же:      sfCursorIns,      TView.HandleEvent,
         TIputLine.SelectAll

 SelectAll  procedure SelectAll(Enable: Boolean);
         Устанавливает CurPos, FirstPos и SelStart в 0. Если Enable
         установлен в True,  SelEnd устанавливается в Length(Data^)
         выбирая таким   образом  всю  строку  ввода.  Если  Enable
         установлен в False,  SelEnd  устанавливается  в  0  снимая
         таким образом выбор всей строки.  Наконец, видимый элемент
         перерисовывается вызовом DrawView.

         См. так же: TView.DrawView

 SetData procedure SetData(var Rec); virtual; Перекрывается: Иногда
         По умолчанию читает DataSize байт из записи в строку Data^
         и вызывает SelectAll(True) для установки  CurPos, FirstPos
         и SelStart в 0; SelEnd устанавливается на последний символ
         Data^ и видимый элемент перерисовывается.  Перекройте этот
         метод, если    Вы   определили   потомка   для   обработки
         нестроковых  типов  данных.  Используйте  этот  метод  для
         преобразования   из   строки   в   Ваш  тип  данных  после
         редактирования с помощью InputLine.

         См. так   же:   TInputLine.DataSize,   TInputLine.GetData,
         TView.DrawView

 SetState  procedure   AetState(AState:  Word;   Enable:  Boolean);
                               virtual;        Перекрывается: Редко
         Вызывается, когда    прямоугольник   ввода   должен   быть
         перерисован (например   при   изменении   палитры)   после
         изменения State.  Вызов  TView.SetState  устанавливает или
         очищает поле  State  видимого  элемента  заданными  битами
         AState. Затем,  если AState - sfSelected или если AState -
         sfActive и прямоугольник ввода - sfSelected, то вызывается
         SelectAll(Enable).

         См. так же: TView.SetState, TView.DrawView

 Store   procedure Store(var S: TStream);
         Сохраняет видимый    элемент     в     потоке,     вызывая
         TView.Store(S), затем  сохраняет  5  целочисленных полей и
         строку Data вызовами  S.Write.  Используется  совместно  с
         TInputLine.Load для  сохранения  и  чтения  всего  объекта
         TInputLine. Перекройте этот  метод,  если  Вы  определяете
         потомка, который содержит дополнительные поля.

         См. так же: TView.Store, TInputLine.Load, TStream.Write

 Палитра───────────────────────────────────────────────────────────

         Строки ввода  используют  палитру  по умолчанию CInputLine
         для отображения  в  элементы  с  19  по  21-й  в   палитре
         стандартного диалогового окна.

                     1    2    3    4
                  ╔════╤════╤════╤════╗
      CInputLine  ║ 19 │ 19 │ 20 │ 21 ║
                  ╚══╤═╧══╤═╧══╤═╧══╤═╝
      Пассивный ─────┘    │    │    └─── Стрелка
      Активный ───────────┘    └──────── Выбранный


 TLabel                                                     Dialogs
═══════════════════════════════════════════════════════════════════

                  ┌─────────────┐
                  │  TObject    │
                  └─────┬───────┘
                  ┌─────┴───────┐
                  │   TView     │
                  └─────┬───────┘
                  ╔═════╧═══════╗
                  ║ TStaticText ║
                  ╚═════╤═══════╝
                  ┌─────┴───────┐
                  │  TLabel     │
                  └─────────────┘

         Объект TLabel  -  это  текст  в видимом элементе,  который
         может быть выбран (подсвечен)  отметкой  мышки,  клавишами
         курсора или   коротким  выбором  Alt-буква.  Метка  обычно
         присоединена через  указатель  PView  к  другому  видимому
         элементу управления,  такому как строка ввода, кластер или
         просмотр списка для  пояснения  пользователю.  Выбор  (или
         нажатие) метки   будет   выбирать  присоединенный  элемент
         управления. Метка  так  же  будет  подсвечиваться,   когда
         выбран связанный элемент управления.

 Поля ─────────────────────────────────────────────────────────────

 Link    Link: PView;                                 Только чтение
         Указывает  на элемент управления, связанный с этой меткой.

 Light   Light: Boolean;                              Только чтение
         Если True  -  метка,  а связанный с ней элемент управления
         будут выбираться и подсвечиваться.

 Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(var Bounds: TRect; AText: String;  ALink:
                          PView);
         Создает объект    TLabel    заданного   размера,   вызывая
         TStaticText.Init, затем устанавливает поле  Link  в  ALink
         для связывания   с  элементом  управления  (задайте  Alink
         равным nil,  если элемент управления не  требуется).  Поле
         Option устанавливается  в  ofPreProcess  и  ofPostProcess.
         EventMask устанавливается    evBroadcast.    Поле    AText
         назначается полю Text через TStaticText.Init.  AText может
         задать клавишу  короткого  набора   для   метки,   окружив
         соответствующую букву "~".

         См. так же: TStaticText.Init

 Load    constructor Load(var S: TStream);
         Создает и  загружает  объект  TLabel  из  потока,  вызывая
         TStaticText.Load, GetPeerViewPtr(S,  Link)  для  установки
         связи с  ассоциированным  элементом  управления  (если  он
         есть).

         См. так же: TLabel.Store

 Draw    procedure Draw; virtual;            Перекрывается: Никогда
         Рисует видимый элемент соответствующим цветом  из  палитры
         по умолчанию.

 GetPalette  function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель на палитру по умолчанию CLabel.

 HandleEvent  procedure HandleEvent(var Event: TEvent); virtual;
                                             Перекрывается: Никогда
         Обрабатывает все события, вызывая TStaticText.HandleEvent.
         Если evMouseDown или  если  получено  событие  от  клавиши
         короткого набора,  выбирается связанный элемент управления
         (если он есть).  Этот  метод  так  же  обрабатывает  общие
         события cmReceivedFocus  и  cmReleasedFocus  от связанного
         элемента управления для настройки значения  поля  Light  и
         перерисовки метки.

         См. так же: TView.HandleEvent, cmXXXX константы команд

 Store   procedure Store(var S: TStream);
         Сохраняет видимый    элемент     в     потоке,     вызывая
         TStaticText.Store, затем      записывает      связь      с
         ассоциированным элементом       управления,        вызывая
         PutPeerViewPtr.

         См. так же: TLabel.Load

 Палитра───────────────────────────────────────────────────────────

         Метки используют   палитру   по   умолчанию   CLabel   для
         отображения в элементы  7,  8  и  9  палитры  стандартного
         диалога.

                     1    2    3    4
                  ╔════╤════╤════╤════╗
      CLabel      ║  7 │  8 │  9 │  9 ║
                  ╚══╤═╧══╤═╧══╤═╧══╤═╝
    Нормальный текст ┘    │    │    └─── Короткая выбранная
    Выбранный текст ──────┘    └──────── Нормальная выбранная


 TListBox                                                   Dialogs
═══════════════════════════════════════════════════════════════════

                  ┌─────────────┐
                  │   TObject   │
                  └──────┬──────┘
                  ┌──────┴──────┐
                  │    TView    │
                  └──────┬──────┘
                  ┌──────┴──────┐
                  │ TListViewer │
                  └──────┬──────┘
                  ╔══════╧══════╗
                  ║  TListBox   ║
                  ╚═════════════╝

         TListBox, порожденный   от   TListViewer,   помогает   Вам
         создавать наиболее   часто   используемые   окна   списков
         отображающих коллекции  строк  таких,  как  имена  файлов.
         Объекты TListBox отображают списки таких элементов  в одну
         или   более   колонок  с  возможной  вертикальной  полосой
         скроллинга. Горизонтальные    полосы     скроллинга     не
         поддерживаются в     TListViewer.    Наследуемые    методы
         TListViewer позволяют Вам выбрать (и  подсветить) элементы
         мышкой или   через  клавиатуру.  TListBox  не  перекрывает
         TListViewer.HandleEvent и  TListViewer.Draw,  поэтому   Вы
         должны просмотреть их описание до использования TListBox в
         своих программах.
         TListBox имеет дополнительное поле List, которое указывает
         на объект TCollection,  содержащий выводимые и  выбираемые
         элементы. Ответственность  за вставку данных в TCollection
         лежит на Вас так же как и действия, выполняемые при выборе
         элемента.
         TListViewer наследует метод Done от TView,  поэтому Вы так
         же отвечаете   за   освобождение   содержимого   List  при
         окончании работы.  Вызов NewList будет освобождать  старый
         список, поэтому    вызов    NewList(nil)   и   последующее
         освобождение окна списка будут освобождать все.

 Поля ─────────────────────────────────────────────────────────────

 List    List: PCollection;                           Только чтение
         List указывает  на коллекцию элементов для просмотра.  Это
         может быть  коллекция  PString,  представляющая  текстовые
         элементы.

 Методы ───────────────────────────────────────────────────────────

 Init    constructor   Init(var  Bounds:  TRect;   ANumCols:  Word;
                            AScrollBar: PScrollBar);
         Создает окно списка с заданным размером,  числом колонок и
         вертикальной полосой  скроллинга,  указываемой  указателем
         AScrollBar. Этот   метод   вызывает   TListViewer.Init   с
         аргументом горизонтальной полосы скроллинга nil.
         Поле List первоначально nil (пустой список)  и наследуемое
         поле Range  устанавливается  в  0.  Ваша  программа должна
         задать TCollection,  содержащую строки (или другие объекты
         для вывода).  Поле  List  должно  быть  установлено на эту
         коллекцию с использованием NewList.

         См. так же: TListViewer.Init, TListBox.NewList

 Load    constructor Load(var S: TStream);
         Создает объект  TListBox  и  загружает  его  значениями из
         TStream. Этот метод вызывает метод TListViewer.Load, затем
         устанавливает List, читая указатель List из S с помощью S.
         Get.

         См. так же: TListViewer.Load, TListBox.Store, TStream.Get

 DataSize  function DataSize: Word; virtual;  Перекрывается: Иногда
         Возвращает размер   читаемых  и  записываемых  данных  для
         записей, передаваемых      в      TListBox.GetData       и
         TListBox.SetData. Эти  3  метода полезны для инициализации
         групп. По умолчанию  TListBox.DataSize  возвращает  размер
         указателя плюс   размер   слова  (для  List  и  выбранного
         элемента). Вам может потребоваться  перекрыть  этот  метод
         для Вашей программы.

         См. так же: TListBox.GetData, TListBox.SetData

 GetData procedure GetData(var Rec); virtual; Перекрывается: Иногда
         Записывает данные объекта TListBox в запись.  По умолчанию
         этот метод  пишет  в Rec текущие поля List и Focused.  Вам
         может потребоваться  перекрыть  этот   метод   для   Вашей
         программы.

         См. так же: TListBox.DataSize, TListBox.SetData

 GetText  function GetText(Item: Integer; MaxLen: Integer): String;
                          virtual;            Перекрывается: Иногда
         Возвращает строку  из  вызываемого  объекта  TListBox.  По
         умолчанию возвращаемая  строка получается из элемента Item
         в TCollection,  используя  PString(List^.At(Item))^.  Если
         List содержит   не   строковые   объекты,  Вам  необходимо
         перекрыть этот метод.  Если List - nil, GetText возвращает
         пустую строку.

         См. так же: TCollection.At

 NewList  procedure NewList(AList: PCollection); virtual;
                                               Перекрывается: Редко
         Если AList  не  nil,  новый  список,  заданные  в   AList,
         заменяет текущий     List.    Наследуемое    поле    Range
         устанавливается в поле Count новой  TCollection  и  первый
         элемент активизируется   вызовом   FocusItem(0).  Наконец,
         новый список отображается вызовом DrawView.  Заметим,  что
         если предыдущее  поле  List  не nil,  оно освобождается до
         назначения нового списка значений.

         См. так   же:   TListBox.SetData,    TListViewer.SetRange,
         TListViewer.FocusItem, TView.DrawView

 SetData procedure SetData(var Rec); virtual; Перекрывается: Иногда
         Заменяет текущий  список  со  значениями  List  и Focused,
         считанными из Rec.  SetData вызывает  NewList  так,  чтобы
         новый список  отображался с корректным активным элементом.
         Как с  GetData  и  DataSize,   Вам   может   потребоваться
         перекрыть этот метод для Вашей программы.

         См.   так    же:   TListBox.DataSize,    TListBox.GetData,
         TListBox.NewList

 Store   procedure Store(var S:TStream);
         Записывает окно списка в TStream, вызывая TListView.Store,
         затем выводит коллекцию в список, вызывая S.Put(List).

         См. так же: TListBox.Load, TListViewer.Store, TStream.Put

 Палитра───────────────────────────────────────────────────────────

         Окна списка  используют палитру  по умолчанию CListViewеr,
         отображая элементы  с  26  по  29  в  палитру  стандартной
         программы.

                  1   2   3   4   5
                ╔═══╤═══╤═══╤═══╤═══╗
   CListViewer  ║ 25│ 26│ 27│ 28│ 29║
                ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
   Активный ──────┘   │   │   │   └── Разделитель
   Неактивный ────────┘   │   └────── Выбранный
   Сфокусированный ───────┘


 TListViewer                                                  Views
═══════════════════════════════════════════════════════════════════

                  ┌─────────────┐
                  │  TObject    │
                  └─────┬───────┘
                  ┌─────┴───────┐
                  │   TView     │
                  └─────┬───────┘
                  ╔═════╧═══════╗
                  ║ TListViewer ║
                  ╚═════╤═══════╝
                  ┌─────┴───────┐
                  │  TListBox   │
                  └─────────────┘

         Тип объекта  TListViewer  -  это базовый тип,  из которого
         порождаются просмотры списков различного вида  такие,  как
         TListBox. Основные поля и методы TListViewer предоставляют
         следующие функции:
         - Видимый   элемент   для  отображения  связанных  списков
           элементов (но не списков).
         - Управление одним или двумя полосами скроллинга.
         - Скроллинг списков по двум координатам.
         - Загрузка  и  сохранение  видимого  элемента  и его полос
           скроллинга из и в TStream.
         - Возможность   выбора   элементов   списка   мышкой   или
           клавишами.
         - Метод Draw поддерживающий изменение размера и скроллинг.

         TListViewer имеет  абстрактный метод GetText так,  что Вам
         потребуется предоставить механизм создания  и  манипуляции
         отображаемых элементов текста.
         TListViewer не имеет  собственного  механизма  запоминания
         списка. Используйте  его  для  отображения  скроллингуемых
         списков, массивов, связанных списков или подобных структур
         данных. Вы  так  же  можете  использовать  его наследников
         таких, как  TListBox,  которые  ассоциируют  коллекцию   с
         просмотром списка.

 Поля ─────────────────────────────────────────────────────────────

 HScroolBar  HScrollBar: PScrollBar;                  Только чтение
         Указатель на горизонтальную полосу скроллинга, связанную с
         этим видимым элементом. Если nil, видимый элемент не имеет
         такой полосы скроллинга.

 VScroolBar  VScrollBar: PScrollBar;                  Только чтение
         Указатель на  вертикальную полосу скроллинга,  связанную с
         этим видимым элементом. Если nil, видимый элемент не имеет
         такой полосы скроллинга.

 NumCols  NumCols: Integer;                           Только чтение
         Число колонок в элементе управления списком.

 TopItem  TopItem: Integer;                           Чтение/Запись
         Номер верхнего отображаемого элемента. Элементы нумеруются
         от 0 до Range-1.  Это  число  зависит  от  числа  колонок,
         размера видимого элемента и значения Range.

         См. так же: Range

 Focused  Focused: Integer;                           Только чтение
         Номер активного элемента.  Элементы  нумеруются  от  0  до
         Range-1. Первоначально   устанавливается   в  0  -  первый
         элемент, Focused  может  изменяться  отметкой  мышки   или
         выбором через пробел.

         См. так же: Range

 Range   Range: Integer;                              Только чтение
         Общее число элементов в списке.  Элементы нумеруются от  0
         до Range-1.

         TListViewer.SetRange


 Методы ───────────────────────────────────────────────────────────

 Init    constructor  Init(var  Bounds:  TRect;  ANumCols: Integer;
                           AHScrollBar, AVScrollBar: PScrollBar);
         Создает и   инициализирует  объект  TListViewer  заданного
         размера, вызывая TView.Init.  Поле NumCols устанавливается
         в ANumCols.  Options  устанавливается  в  (ofFirstClick  +
         ofFirstSelectable) так,  что выбор мышкой  этого  элемента
         будет передаваться  в  TListViewer.HandleEvent.  EventMask
         устанавливается в evBroadcast.  Начальные значения Range и
         Focused -    0.    Указатели    на    вертикальную   и/или
         горизонтальную полосы  скроллинга   можно   задать   через
         аргументы AVScrollBar  и  AHSсrollBar.  Если  Вам не нужны
         полосы скроллинга,  можно установить один из них или оба в
         nil. Эти  значения аргументов назначаются полям VScrollBar
         и HScrollBar.
         Если Вы задали полосы скроллинга,  их поля PgStep и ArStep
         будут настраиваться в соответствии с  размером TListViewer
         и числом    колонок.    Например,    для   одноколоночного
         TListViewer вертикальный   PgStep   равен   Size.Y-1,    а
         вертикальный ArStep равен 1.

         См. так же: TView.Init, TScrollBar.SetStep

 Load    Load constructor Load(var S: TStream);
         Создает объект  TListViewer,  вызывая  TView.Load.  Полосы
         скроллинга, если они есть,  так же загружаются из потока с
         использованием вызовов GetPeerViewPtr.  Все  целочисленные
         поля загружаются с использованием S.Read.

         См. так же: TView.Load, TListViewer.Store

 ChangeBounds  ChangeBounds(var Bounds: TRect); virtual;
                                             Перекрывается: Никогда
         Изменяет размер     объекта      TListViewer,      вызывая
         TView.ChangeBounds. Если  назначена  горизонтальная полоса
         скроллинга, этот  метод  при   необходимости   настраивает
         PgStep.

         См. так же: TView.ChangeBounds, TScrollBar.ChangeStep

 Draw    procedure Draw; virtual;            Перекрывается: Никогда
         Рисует объект TListViewer палитрой по  умолчанию,  вызывая
         GetText для  каждого  отображаемого элемента,  принимая во
         внимание активные  и  выбранные  элементы  и  является  ли
         видимый элемент sfActive.

         См. так же: TListViewer.GetText

 FocusItem  procedure FocusItem(Item: Integer); virtual;
                                             Перекрывается: Никогда
         Делает данный элемент активным,  устанавливая поле Focused
         в Item.   Этот  метод  так  же  устанавливает  поле  Value
         вертикальной полосы  скроллинга  (если  есть)  в  Item   и
         настраивает поле TopItem.

         См. так же: TListViewer.IsSelected, TScrollBar.SetValue

 GetPalette  function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель на палитру по умолчанию.

 GetText  function GetText(Item: Integer; MaxLen: Integer): String;
                          virtual;            Перекрывается: Всегда
         Это абстрактный метод.  Порожденные типы должны определить
         механизм для возвращения строки,  не превышающей MaxLen по
         индексу, заданному в Item.

         См. так же: TListViewer.Draw

 IsSelected  function IsSelected(Item: Integer): Boolean; virtual;
                                             Перекрывается: Никогда
         Возвращает True,  если Item активный,  т.е.  если  Item  =
         Focused.

         См. так же: TListViewer.FocusItem

 HandleEvent  procedure HandleEvent(var Event: TEvent); virtual;
                                               Перекрывается: Редко
         Обрабатывает события,  вызывая TView.HandleEvent.  Отметки
         мышкой и   "автоматические"   движения   по  списку  будут
         изменять активный элемент.  Активные элементы  могут  быть
         выбраны двойным нажатием мышки.  Обрабатываются события от
         клавиатуры: пробел  выбирает  текущий  активный   элемент;
         клавиши стрелок,  PgUp, PgDn, Ctrl-PgUp, Ctrl-PgDn, Home и
         End изменяют активный элемент.  Наконец общие сообщения от
         полос скроллинга обрабатываются,  изменяя активный элемент
         и перерисовывая видимый элемент.

         См. так же: TView.HandleEvent, TListViewer. FocusItem

 SelectItem  procedure SelectItem(Item: Integer); virtual;
                                              Перекрывается: Иногда
         Абстрактный метод   для  выбора  элемента,  индексируемого
         через Item.

         См. так же: TListViewer.FocusItem

 SetRange  procedure SetRange(ARange: Integer);
         Устанавливает поле   Range  в  ARange.  Если  вертикальная
         полоса скроллинга была задана, ее параметры настраиваются.
         Если текущий активный элемент выходит за новый Range, поле
         Focused устанавливается в 0.

         См. так же: TListViewer.Range, TScrollBar.SetParams

 SetState  procedure   SetState(AState:  Word;   Enable:  Boolean);
                               virtual;        Перекрывается: Редко
         Вызывает TView.SetState  для  изменения  состояния объекта
         TListViewer, если  Enable  -  True.   В   зависимости   от
         аргумента  AState  это  приводит к отображению или скрытию
         видимого элемента. Дополнительно, если AState - sfSelected
         и   sfActive,  полосы  скроллинга  перерисовываются;  если
         AState - sfSelected,  но не  sfActive,  полосы  скроллинга
         скрываются.

         См. так      же:      TView.SetState,     TScrollBar.Show,
         TScrollBar.Hide

 Store   procedure Store(var S: TStream);
         Вызывает TView.Store для сохранения объекта  TListViewer в
         потоке, затем сохраняет объекты полос скроллинга (если они
         есть) используя    PutPeerViewPtr,    наконец    сохраняет
         целочисленные поля через S.Write.

         См. так же: TView.Store, TListViewer.Load

 Палитра───────────────────────────────────────────────────────────

         Списки просмотра    используют    палитру   по   умолчанию
         CListViewer, отображая элементы с 26  по  29-й  в  палитру
         стандартной программы.


                  1   2   3   4   5
                ╔═══╤═══╤═══╤═══╤═══╗
   CListViewer  ║ 25│ 26│ 27│ 28│ 29║
                ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
   Активный ──────┘   │   │   │   └── Разделитель
   Неактивный ────────┘   │   └────── Выбранный
   Сфокусированный ───────┘


 TMenuBar                                                     Menus
═══════════════════════════════════════════════════════════════════

                  ┌────────────┐
                  │   TObject  │
                  └──────┬─────┘
                  ┌──────┴─────┐
                  │    TView   │
                  └──────┬─────┘
                  ┌──────┴─────┐
                  │ TMenuView  │
                  └────┬───┬───┘
              ┌────────┘   └──────┐
         ╔════╧═════╗        ┌────┴─────┐
         ║ TMenuBar ║        │ TMenuBox │
         ╚══════════╝        └──────────┘

         Объекты TMenuBar представляют полосы горизонтального меню,
         из которого меню может быть выбрано через:
         - прямую отметку.
         - F10 и короткую клавишу.
         - выбор (подсветку) и нажатие Enter.
         - горячие клавиши.
         Выборы главного меню отображаются в верхней  полосе  меню.
         Они представлены    объектом    типа    TMenuBar    обычно
         принадлежащему объекту TApplication.  Подменю отображаются
         в объектах типа TMenuBox.  TMenuBar и TMenuBox порождаются
         от абстрактного типа TMenuView.
         Для большинства  программ  на Turbo Vision Вы не включаете
         прямо объекты  меню.  Перекрывая  TApplication.InitMenuBar
         соответствующим набором вложенных вызовов New, NewSubMenu,
         NewItem и NewLine, Turbo Vision выполняет это.

 Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(var Bounds: TRect; AMenu: PMenu);
         Создает полосу   меню,   заданную  через  Bounds,  вызывая
         TMenuView.Init. GrowMode  установлена  в  gfGrouHiX.  Поле
         Options установлено  в ofPreprocess для возможности работы
         с горячими  клавишами.  Поле  меню  установлено  в  AMenu,
         задавая элементы меню.

         См. так же: TMenuView.Init, gfXXXX флаги grow mode, ofXXXX
         флаги опций, TMenuView.Menu

 Draw    procedure Draw; virtual;              Перекрывается: Редко
         Рисует полосу меню палитрой  по  умолчанию.  Поля  Name  и
         Disabled каждой   записи   TMenuItem  в  связанном  списке
         читаются, чтобы  установить  элементы  меню  в  корректный
         цвет. Текущий элемент Current подсвечивается.

 GetItemRect  procedure GetIteRect(Item: PMenuItem;  var R: TRect);
                                  virtual;   Перекрывается: Никогда
         Перекрывает абстрактный  метод  в  TMenuView.   Возвращает
         прямоугольник, занимаемый элементом меню в R. Используется
         для определения,  находится  ли  отметка  мышки  в  данном
         элементе меню.

         См. так же: TMenuView.GetItemRect

 Палитра───────────────────────────────────────────────────────────

         Полосы меню,  как и все видимые элементы меню,  используют
         палитру по умолчанию CMenuView для  отображения  элементов
         со 2 по 7 в палитру стандартной программы.

                  1    2    3    4    5    6
               ╔════╤════╤════╤════╤════╤════╗
CMenuView      ║  2 │  3 │  4 │  5 │  6 │  7 ║
               ╚══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╝
Нормальный текст ─┘    │    │    │    │    └── Короткий выбранный
Запрещенный текст ─────┘    │    │    └────── Запрещенный выбранный
Короткий текст ─────────────┘    └──────────── Нормальный выбранный


 TMenuBox                                                     Menus
═══════════════════════════════════════════════════════════════════

                  ┌────────────┐
                  │   TObject  │
                  └──────┬─────┘
                  ┌──────┴─────┐
                  │    TView   │
                  └──────┬─────┘
                  ┌──────┴─────┐
                  │ TMenuView  │
                  └────┬───┬───┘
              ┌────────┘   └──────┐
         ┌────┴─────┐        ╔════╧═════╗
         │ TMenuBar │        ║ TMenuBox ║
         └──────────┘        ╚══════════╝

         Объекты MenuBox представляют  вертикальные  прямоугольники
         меню. Они  могут  содержать произвольный список выбираемых
         действий, включая элементы подменю.  Как и в полосе  меню,
         для указания   запрещенных  элементов  используется  цвет.
         Прямоугольники меню могут создаваться как  подменю  полосы
         меню или    других    прямоугольников   меню   или   могут
         использоваться как отдельные выпадающие меню.

 Методы ───────────────────────────────────────────────────────────

 Init    constructor   Init(var  Bounds:  TRect;    Amenu:   PMenu;
                            AParentMenu: PMenuView);
         Init настраивает  параметр Bounds в соответствии с шириной
         и длиной элементов в AMenu,  затем  создает  прямоугольник
         меню, вызывая TMenuView.Init.
         Бит ofPreProcess в  поле  Options  установлен  так,  чтобы
         могли использоваться   горячие  клавиши.  Установка  State
         включает sfShadow.  Поле меню установлено в AMenu, которое
         задает элементы   меню.   Поле  ParentMenu  установлено  в
         AParentMenu.

         См. так же: TMenuView.Init, sfXXXX флаги состояний, ofXXXX
         флаги опций, TMenuView.Menu, TMenuView.ParentMenu

 Draw    procedure Draw; virtual;              Перекрывается: Редко
         Рисует рамку прямоугольника меню и элементы меню цветом по
         умолчанию.

 GetItemRect  procedure  GetItemRect(Item: PMenuItem; var R: TRect;
                                    virtual;   Перекрывается: Редко
         Перекрывает абстрактный   метод  в  TMenuView.  Возвращает
         прямоугольник, занятый элементом  меню.  Используется  для
         определения, находится   ли   отметка   мышкой  на  данном
         элементе меню.

         См. так же: TMenuView.GetItemRect

 Палитра ──────────────────────────────────────────────────────────

         Прямоугольники меню,  как и  все  видимые  элементы  меню,
         используют  палитру по умолчанию CMenuView для отображения
         элементов со 2 по 7 в палитру стандартной программы.

                  1    2    3    4    5    6
               ╔════╤════╤════╤════╤════╤════╗
CMenuView      ║  2 │  3 │  4 │  5 │  6 │  7 ║
               ╚══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╝
Нормальный текст ─┘    │    │    │    │    └── Короткий выбранный
Запрещенный текст ─────┘    │    │    └────── Запрещенный выбранный
Короткий текст ─────────────┘    └──────────── Нормальный выбранный


 TMenuView                                                    Menus
═══════════════════════════════════════════════════════════════════

                  ┌────────────┐
                  │   TObject  │
                  └──────┬─────┘
                  ┌──────┴─────┐
                  │    TView   │
                  └──────┬─────┘
                  ╔══════╧═════╗
                  ║ TMenuView  ║
                  ╚════╤═══╤═══╝
              ┌────────┘   └──────┐
         ┌────┴─────┐        ┌────┴─────┐
         │ TMenuBar │        │ TMenuBox │
         └──────────┘        └──────────┘

         TMenuView предоставляет тип абстрактного меню, из которого
         порождаются полосы  и  прямоугольники  меню.  Вы  вероятно
         никогда не будете создавать экземпляров TMenuView.

 Поля ─────────────────────────────────────────────────────────────

 ParentMenu  ParenMenu: PMenuView;                    Только чтение
         Указатель на объект TMenuView (или порожденный  от  него),
         который владеет  этим  меню.  Заметим,  что TMenuView - не
         группа. Здесь  принадлежность  намного  проще,   чем   для
         TGroup, позволяя   вложенность   меню:   выбор  подменю  и
         обратный возврат в "родительское" меню.  Выборы  из  полос
         меню, например,  обычно приводят к "выпаданию" подменю.  В
         этом случае полоса меню - предок прямоугольника меню.

         См. так же: TMenuBox.Init

 Menu    Menu: PMenu;                                 Только чтение
         Указатель на запись TMenu для этого меню, которая содержит
         связанный список элементов меню.  Указатель меню позволяет
         обращаться ко всем полям элементов меню в видимом элементе
         меню.

         См. так же: TMenuView.FindItem, TMenuView.GetItemRect, тип
         TMenu

 Current  Current: PMenuItem;                         Только чтение
         Указатель на текущий выбранный элемент меню.

 Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(var Bounds: TRect);
         Вызывает TView.Init,  чтобы   создать   объект   TMenuView
         размера Bounds.   По  умолчанию  EventMask  установлено  в
         evBroadcast. Этот метод не предназначен  для использования
         с экземплярами  объектов  TMenuView.  Он  предназначен для
         вызова из порожденных типов TMenuBar и TMenuBox.

         См. так   же:   TView.Init,   evBroadcast,  TMenuBar.Init,
         TMenuBox.Init

 Load    constructor TMenuView.Load(var S: TStream);
         Создает объект  TMenuView  и  загружает  его  из  потока S
         вызывая TView.Load,  а затем загружая  элементы  в  список
         меню.

         См. так же: TView.Load, TMenuView.Store

 Execute  function Execute: Word; virtual;   Перекрывается: Никогда
         Выполняет видимый  элемент   меню   до   тех   пор,   пока
         пользователь не  выберет  элемент меню или не отменит этот
         процесс. Возвращает   команду,   назначенную    выбранному
         элементу меню,  или 0, если меню было отменено. Этот метод
         должен вызываться только из ExecView.

         См. так же: TGroup.ExecView

 FindItem  function FindItem(Ch: Char): PMenuItem);
         Возвращает указатель на элемент меню, который имеет Ch как
         горячую клавишу  (подсвеченный  символ).  Возвращает  nil,
         если такой  элемент  не  найден или этот элемент запрещен.
         Заметим, что для Ch не различаются  прописные  и  строчные
         буквы.

 GetItemRect  procedure GetItemRect(Item: PMenuItem; var R: TRect);
                                   virtual;   Перекрывается: Всегда
         Этот метод возвращает в R прямоугольник, занимаемый данным
         элементом меню.  Используется  для определения,  не был ли
         отмечен данный элемент мышкой. Наследники TMenuView должны
         перекрывать этот  метод  для  того,  чтобы  откликаться на
         события от мышки.

         См. так же: TMenuBar.GetItemRect, TMenuBox.GetItemRect

 GetHelpCtx  function GetHelpCtx: Word; virtual;
                                              Перекрывается: Иногда
         По умолчанию  этот  метод  возвращает  контекст  подсказки
         текущего элемента меню.  Если это hcNoContext,  выбирается
         текущий контекст  родительского  меню.  Если родительского
         меню нет, GetHelpCtx возвращает hcNoContext.

         См. так же: hcXXXX константы контекста help

 GetPalette  function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель на палитру по умолчанию CMenuView.

 HandleEvent  procedure HandleEvent(var Event: TEvent); virtual;
                                             Перекрывается: Никогда
         Вызывается для обработки событий меню.  Определяет,  какой
         элемент меню  был  выбран  мышкой или клавиатурой (включая
         горячие клавиши) и  генерирует  соответствующее  командное
         событие через PutEvent.

         См. так же: TView.HandleEvent, TView.PutEvent

 HotKey  function HotKey(KeyCode: Word): PMenuItem;
         Возвращает указатель на элемент меню,  связанный с горячей
         клавишей, заданной через KeyCode.  Возвращает nil, если не
         существует такого элемента меню или если элемент запрещен.
         Горячие клавиши  -  это  обычно функциональные клавиши или
         комбинации Alt ключей и определяются аргументами в вызовах
         NewItem и    NewSubMenu    в   InitMenuBar.   Этот   метод
         используется в  TMenuView.HandleEvent   для   определения,
         будет ли событие от клавиатуры вибирать элемент меню.

 Store   procedure Store(var S: TStream);
         Сохраняет объект TMenuView (и его  подменю)  в  потоке  S,
         вызывая TView.Store, а затем записывая каждый элемент меню
         в поток.

         См. так же: TMenuView.Load

 Палитра───────────────────────────────────────────────────────────

         Все видимые элементы меню используют палитру  по умолчанию
         CMenuView  для  отображения  элементов со 2 по 7 в палитру
         стандартной программы.

                  1    2    3    4    5    6
               ╔════╤════╤════╤════╤════╤════╗
CMenuView      ║  2 │  3 │  4 │  5 │  6 │  7 ║
               ╚══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╝
Нормальный текст ─┘    │    │    │    │    └── Короткий выбранный
Запрещенный текст ─────┘    │    │    └────── Запрещенный выбранный
Короткий текст ─────────────┘    └──────────── Нормальный выбранный


 TObject                                                    Objects
═══════════════════════════════════════════════════════════════════

                     ╔═══════════╗
                     ║  TObject  ║
                     ╚╤═╤═╤═╤═╤═╤╝
            ┌─────────┘ │ │ │ │ └─────────┐
    ┌───────┴───────┐   │ │ │ │   ┌───────┴───────┐
    │  TCollection  │   │ │ │ │   │ TResourceFile │
    └───────────────┘   │ │ │ │   └───────────────┘
            ┌───────────┘ │ │ └──────────┐
    ┌───────┴───────┐     │ │    ┌───────┴───────┐
    │   TStream     │     │ │    │ TStringList   │
    └───────────────┘     │ │    └───────────────┘
            ┌─────────────┘ └─────────────┐
    ┌───────┴───────┐             ┌───────┴───────┐
    │ TStrListMaster│             │ TView         │
    └───────────────┘             └───────────────┘

         TObjеct - это  начальная  точка  иерархии  объектов  Turbo
         Vision. Как  базовый объект он не имеет предков,  но имеет
         множество потомков.  Кроме TPoint и ТRect все  стандартные
         объекты Turbo   Vision   порождены  в  конечном  счете  от
         TObject. Любой объект,  использующий потоки Turbo  Vision,
         должен происходить от TObject.

 Методы ───────────────────────────────────────────────────────────

 Init    constructor Init;
         Распределяет память в куче для  объекта  и  заполняет  его
         нулями. Вызывается   из   констракторов  всех  порожденных
         объектов. Заметим,  что TObject.Init будет  заполнять  все
         поля в потомках так, что Вы должны вызвать TObject.Init до
         инициализации любых  полей  в  констракторах   порожденных
         объектов.

 Free    procedure Free;
         Освобождает объект и вызывает дестрактор Done.

 Done    destructor Done; virtual;
         Выполняет необходимую  очистку и освобождение динамических
         объектов.


 TParamText                                                 Dialogs
═══════════════════════════════════════════════════════════════════

         TParamText порожден  от  TStaticText,  который  использует
         параметризованные строки  текста  для  форматного  вывода,
         используя процедуру FormatStr.

 Поля ─────────────────────────────────────────────────────────────

 ParamCount  ParamCount: Integer;
         ParamCount указывает   число  параметров,  содержащихся  в
         ParamList.

         См. так же: TParamText.ParamList

 ParamList  ParamList: Pointer;
         ParamList -  это  нетипированный  указатель  на массив или
         запись указателей или значений типа  LongInt, используемый
         как параметр форматирования для текстовой строки.

 Методы ───────────────────────────────────────────────────────────

 Init    constructor    Init(var  Bounds:  TRect;   AText:  String;
                             AParamCount: Integer);
         Инициализирует объект   статического    текста,    вызывая
         TStaticText.Init с  заданным  Bounds  и  текстовой строкой
         AText, которая может  содержать  спецификаторы  формата  в
         форме %[-][nnn]X,  который  будет  замещаться параметрами,
         переданными во   время   выполнения.   Число   параметров,
         переданных в  ParamCount,  присваивается  полю ParamCount.
         Спецификаторы формата   детально   описаны   в   процедуре
         FormatStr.

         См. так же: TStaticText.Init, FormatStr процедуры

 Load    constructor Load(var S: TStream);
         Распределяет объект TParamText  в  куче  и  загружает  его
         занчение из  потока  S,  вызывая  TStaticText.Load,  затем
         читая поле ParamCount из потока.

         См. так же: TStaticText.Load

 DataSize  function DataSize: Word; virtual;
         Возвращает размер  данных,  требуемый параметрами объекта,
         т.е. ParamCount*SizeOf(LongInt).

 GetText  procedure GetText(var S: String); virtual;
         Создает форматированную   строку   текста  в  S,  выполняя
         объединение параметров,  заданных в ParamList в  текстовую
         строку  Text  с   помощью    вызова   FormatStr(S,  Text^,
         ParamList^).

         См. так же: FormatStr процедуры

 SetData  procedure SetData(var Rec); virtual;
         Этот видимый  элемент  читает DataSize байт в ParamList из
         Rec.

         См. так же: TView.SetData

 Store   procedure Store(var S: TStream);
         Сохраняет объект  в  потоке S,  вызывая TStaticText.Store,
         затем записывая поле ParamCount в поток.

         См. так же: TStaticText.Store

 Палитра───────────────────────────────────────────────────────────

         Объекты TParamText   используют   палитру   по   умолчанию
         CStaticText для   отображения   6-го  элемента  в  палитру
         стандартного диалога.

                               1
                             ╔═══╗
             CStaticText     ║ 6 ║
                             ╚═╤═╝
                    Текст ─────┘


 TPoint                                                     Objects
═══════════════════════════════════════════════════════════════════

         TPoint -  это  простой  объект,  представляющий  точку  на
         экране.

 Поля ─────────────────────────────────────────────────────────────

 X       X: Integer;
         Х - это колонка точки на экране.

 Y       Y: Integer;
         Y - это строка точки на экране.


 TProgram                                                       App
═══════════════════════════════════════════════════════════════════

                    ┌─────────┐
                    │ TObject │
                    └────┬────┘
                    ┌────┴────┐
                    │  TView  │
                    └────┬────┘
                    ┌────┴────┐
                    │ TGroup  │
                    └─┬──┬──┬─┘
           ┌──────────┘  │  └────────────┐
      ┌────┴────┐   ┌────┴─────┐  ╔══════╧═══════╗
      │ TWindow │   │ TDeskTop │  ║ TProgram     ║
      └────┬────┘   └──────────┘  ╚══════╤═══════╝
      ┌────┴────┐                 ┌──────┴───────┐
      │ TDialog │                 │ TApplication │
      └─────────┘                 └──────────────┘

         TProgram обеспечивает    базовую    заготовку   для   всех
         стандартных программ на Turbo Vision.  Все такие программы
         должны порождаться    от    TProgram   или   его   потомка
         TApplication. TApplication отличается от  TProgram  только
         констрактором и     дестрактором.     2    типа    объекта
         предоставляются для   большей   гибкости   при    создании
         нестандартных   программ.   В   большинстве  случает  Ваша
         программа  будет  порождаться  от  TApplication.  TProgram
         порождается  от  TGroup,  поскольку  она  должна содержать
         объекты TDeskTop, TStatusLine и TMenuBar.

 Методы ───────────────────────────────────────────────────────────

 Init    constructor Init;                    Перекрывается: Иногда
         Устанавливает глобальную  переменную  Application в @Self;
         вызывает TProgram.InitScreen для инициализации переменных,
         определяющих режим экрана;  вызывает TGroup.Init передавая
         прямоугольник Bounds равный полному  экрану; устанавливает
         поле State  в sfVisible + sfSelected + sfFocused + sfModal
         + sfExposed; устанавливает поле Options в 0; устанавливает
         поле Buffer   в   адрес   экранного  буфера,  заданного  в
         ScreenBuffer; наконец вызывает InitDeskTop, InitStatusLine
         и InitMenuBar  и  вставляет  эти видимые элементы в группу
         TProgram.

         См. так     же:     TGroup.Init,     TProgram.InitDeskTop,
         TProgram.InitStatusLine, TProgram.InitMenuBar

 Done    destructor Done; virtual;            Перекрывается: Иногда
         Освобождает объекты   DeskTop,   MenuBar  и  StatusLine  и
         устанавливает глобальную переменную Application в nil.

         См. так же: TGroup.Done

 GetEvent  procedure GetEvent(var Event: TEvent); virtual;
                                               Перекрывается: Редко
         По умолчанию   TView.GetEvent   просто  вызывает  GetEvent
         своего владельца и поскольку TProgram (или TApplication) в
         конечном итоге   являются   владельцем   любого   видимого
         элемента, любой вызов GetEvent будет приводить к TProgram.
         GetEvent (если   только   видимый   элемент  не  перекроет
         GetEvent)
         TРrogram.GetEvent вначале  проверяет,  не  сгенерировал ли
         TProgram.PutEvent событие. Если да, то GetEvent возвращает
         это событие.   Если   нет   пришедшего  события,  GetEvent
         вызывает GetMouseEvent;  если  тот  возвращает  evNothing,
         вызывается GetKeyEvent,  если  оба  возвращают  evNothing:
         указывая, что нет ввода от пользователя, GetEvent вызывает
         TProgram.Idle, чтобы     запустить    "фоновые"    задачи,
         выполняемые во время ожидания ввода  от  пользователя.  До
         возврата GetEvent   передает   все   события  evKeyDown  и
         evMouseDown в StatusLine для отображения в ассоциированные
         события от горячих клавиш evCommand.

         См. так же: TProgram.PutEvent, GetMouseEvent, GetKeyEvent

 GetPalette  function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель на палитру, заданную индексом палитры
         в глобальной переменной AppPalette.  TProgram поддерживает
         3   палитры:   apColor,   apBlackWhite   и   apMonochrome.
         Переменная       AppPalette       инициализируется       в
         TProgram.InitScreen.

         См. так   же:   TProgram.InitScreen,   AppPalette,  apXXXX
         константы

 HandleEvent  procedure HandleEvent(var Event: TEvent); virtual;
                                              Перекрывается: Всегда
         Обрабатывает событие  от  клавиатуры  от  Alt-1  до  Alt-9
         генерируя событие evBroadcast с значением  Command  равным
         cmSelectWindowNum и      значением      InfoInt      1..9.
         TWindow.HandleEvent реагирует на такие  сообщения, выбирая
         окно с данным номером.
         Обрабатывает событие evCommand со значением Command равным
         cmQuit вызывая   EndModal(cmQuit)   которое   приводит   к
         завершению программы.
         TProgram.Handle почти  всегда  перекрывается  для введения
         обработки команд, специфичных для Вашей программы.

         См. так же: TGroup.HandleEvent

 Idle    procedure Idle; virtual;             Перекрывается: Иногда
         Idle вызывается из TProgram.GetEvent когда очередь событий
         пуста, позволяя программе  выполнять  фоновые  задачи  при
         ожидании ввода от пользователя.
         По умолчанию  TProgram.Idle  вызывает  StatusLine^.Update,
         чтобы разрешить    строке   статуса   обновлять   себя   в
         соответствии с текущим констекстом подсказки.  Затем, если
         набор команд    изменился    после    последнего    вызова
         TProgram.Idle, генерируется   evBroadcast   со   значением
         Command равным    cmCommandSetChanged,   чтобы   разрешить
         видимому элементу, который зависит от этого набора команд,
         разрешить или запретить себя.
         Если Вы перекрываете Idle,  всегда  вызывайте  наследуемый
         Idle. Так  же убедитесь,  что любые задачи,  выполняемые в
         Вашем Idle,  не  занимают  слишком  большого   времени   в
         программе, поскольку    это    будет    блокировать   ввод
         пользователя.

 InitDeskTop procedure InitDeskTop; virtual;   Перекрывается: Редко
         Создает  объект   TDeskTop   для   программы  и  сохраняет
         указатель на  него  в   глобальной   переменной   DeskTop.
         InitDeskTop вызывается в TProgram.Init и никогда не должен
         вызываться прямо.   InitDeskTop   может   быть    перекрыт
         созданием потомка от TDeskTop.

         См. так же: TProgram.Init, TDeskTop, TWindow.Init

 InitMenuBar procedure InitMenuBar; virtual;  Перекрывается: Всегда
         Создает объект  TMenuBar   для   программы   и   сохраняет
         указатель на  него  в  глобальной  переменной  в  MenuBar.
         InitMenuBar вызывается в TProgram.Init и никогда не должен
         вызываться прямо.  InitMenuBar  почти всегда перекрывается
         потомком от TMenuBar, определенным пользователем.

         См. так же: TProgram.Init, TMenuBar, TWindow.Init

 InitScreen procedure InitScreen; virtual;    Перекрывается: Иногда
         Вызывается из   TProgram.Init   и   TProgram.SetScreenMode
         каждый раз,  когда  режим  экрана   инициализируется   или
         изменяется. Это  метод,  который  действительно  выполняет
         обновление и  настройку  переменных,  определяющих   режим
         экрана для размера тени, маркеров и палитры программы.

         См. так же: TProgram.Init, TProgram.SetScreenMode

 InitStatusLine procedure InitStatusLine; virtual;
                                              Перекрывается: Всегда
         Создает объект   TStatusLine  для  программы  и  сохраняет
         указатель на него в глобальной  переменной  в  StatusLine.
         InitStatusLine  вызывается  в  TProgram.Init  и никогда не
         должен  вызываться  прямо.  InitStatusLine  почти   всегда
         перекрывается   потомком   от   TStatusLine,  определенным
         пользователем.

         См. так же: TProgram.Init, TStatusLine

 OutOfMemory procedure OutOfMemory; virtual;   Перекрывается: Часто
         OutOfMemory вызывается     из    TProgram.ValidView    для
         определения, что  LowMemory  -  True.  OutOfMemory  должна
         сообщать пользователю,   что   недостаточно   памяти   для
         выполнения операции.  Например с использованием  программы
         MessageBox из модуля StdDlg:

         procedure TMyApp.OutOfMemory;
         begin
           MessageBox('Not enough memory to complete operation.',
                      nil, mfError + mfOKButton);
         end;

         См. так же: TProgram.ValidView, LowMemory

 PutEvent procedure PutEvent(var Event: TEvent); virtual;
                                               Перекрывается: Редко
         По умолчанию   TView.PutEvent   просто  вызывает  PutEvent
         своего владельца  и   поскольку   объект   TProgram   (или
         TApplication) в  конечном счете является владельцем любого
         видимого элемента, каждый вызов PutEvent будет приводить к
         TProgram.PutEvent (если только видимый элемент не перекрыл
         PutEvent).
         Program.PutEvent сохраняет  копию записи PutEvent в буфере
         и следующий вызов в  TPreogram.GetEvent  будет  возвращать
         эту копию.

         См. так же: TProgram.GetEvent, TView.PutEvent

 Run     procedure Run; virtual;               Перекрывается: Редко
         Выполняет TProgram,   вызывая   метод   Execute   (который
         TProgram наследует от TGroup).

         См. так же: TGroup.Execute

 SetScreenMode procedure SetScreenMode(Mode: Word);
         Устанавливает режим  экрана.  Mode  -  одна  из   констант
         smCO80, smBW80  или  smMono с дополнительным smFont8x8 для
         выбора 43-  или  50-строчного  режима  на  EGA  или   VGA.
         SetScreenMode скрывает  мышку,  вызывает  SetVideoMode для
         изменения режима   экрана,   вызывает    InitScreen    для
         инициализации переменных    режима    экрана,    назначает
         ScreenBuffer в TProgram.Buffer,  вызывает  ChangeBounds  с
         новым прямоугольником экрана и, наконец, показывает мышку.

         См. так   же:  TProgram.InitScreen,  SetVideoMode,  smXXXX
         константа

 ValidView function TProgram.ValidView(P: PView): PView;
         Проверяет правильность  вновь созданных видимых элементов,
         возвращая Р,  если видимый элемент правильный и nil - если
         нет. Во-первых,  если Р - nil,  возвращается значение nil.
         Во-вторых, если LowMemory -  True,  при  вызове  ValidView
         видимый элемент,  заданный в Р,  освобождается, вызывается
         метод OutOfMemory и возвращается значение  nil. В-третьих,
         если вызов  P^.Valid(cmValid)  возвращает  False,  видимый
         элемент освобождается и возвращается значение  nil.  Иначе
         видимый элемент   считается   правильным   и  возвращается
         указатель на этот видимый элемент Р.
         ValidView часто  используется  для  проверки  правильности
         нового видимого элемента  до  вставки  его  во  владельца.
         Например, следующий     оператор    показывает    типичную
         последовательность создания,  проверки  и  вставки  нового
         окна в  панель  экрана (TProgram.ValidView и TGroup.Insert
         знают как   игнорировать    возможные    указатели    nil,
         возникающие в результате ошибок).

         DeskTop^.Insert(ValidView(New(TMyWindow, Init(...))));

         См. так же: LowMemory, TProgram.OutOfMemory, Valid методы

Палитра ───────────────────────────────────────────────────────────

         Палитра для    объекта-программа    управляет     конечным
         отображением  цвета всех видимых элементов программы.  Все
         отображения других палитр приводят  к  выбору  элемента  в
         палитре программы,  которая задает атрибуты текста. Первый
         элемент  используется  в  TBackground  для  цветов   фона.
         Элементы со 2 по 7 используются меню и строкой статуса.

               1   2   3   4   5   6   7
             ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╗
CColor       ║$71│$70│$78│$74│$20│$28│$24║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CBlackWhite  ║$70│$70│$78│$7F│$07│$07│$0F║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CMonochrome  ║$70│$07│$07│$0F│$70│$70│$70║
             ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
Фон        ────┘   │   │   │   │   │   └── Короткий выбор
Нормальный текст ──┘   │   │   │   └────── Запрещенный выбор
Запрещенный текст ─────┘   │   └────────── Нормальный выбор
Короткий текст ────────────┘

         Элементы в 8 по 15 используются голубыми окнами.

               8   9   10  11  12  13  14  15
             ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
CColor       ║$17│$1F│$1A│$31│$31│$1E│$71│$00║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CBlackWhite  ║$07│$0F│$07│$70│$70│$07│$70│$00║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CMonochrome  ║$07│$0F│$07│$70│$70│$07│$70│$00║
             ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
Рамка пассивна ┘   │   │   │   │   │   │   └── Зарезервировано
Рамка активна ─────┘   │   │   │   │   └─ Выбранный текст скроллера
Кнопка рамки ──────────┘   │   │   └──── Нормальный текст скроллера
Страница скроллинга ───────┘   └──────── Зарезервировано


         Элементы с 16 по 23 используются бирюзовыми окнами.

               16  17  18  19  20  21  22  23
             ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
CColor       ║$37│$3F│$3A│$13│$13│$3E│$21│$00║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CBlackWhite  ║$07│$0F│$07│$70│$70│$07│$70│$00║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CMonochrome  ║$07│$0F│$07│$70│$70│$07│$70│$00║
             ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
Рамка пассивна ┘   │   │   │   │   │   │   └── Зарезервировано
Рамка активна ─────┘   │   │   │   │   └─ Выбранный текст скроллера
Кнопка рамки ──────────┘   │   │   └──── Нормальный текст скроллера
Страница скроллинга ───────┘   └──────── Зарезервировано


         Элементы с 24 по 31 используются серыми окнами.

               24  25  26  27  28  29  30  31
             ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
CColor       ║$70│$7F│$7A│$13│$13│$70│$7F│$00║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CBlackWhite  ║$70│$7F│$7F│$70│$07│$70│$07│$00║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CMonochrome  ║$70│$70│$70│$07│$07│$70│$07│$00║
             ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
Рамка пассивна ┘   │   │   │   │   │   │   └── Зарезервировано
Рамка активна ─────┘   │   │   │   │   └─ Выбранный текст скроллера
Кнопка рамки ──────────┘   │   │   └──── Нормальный текст скроллера
Страница скроллинга ───────┘   └──────── Зарезервировано

         Элементы с 32 по 63 используются диалоговыми  окнами.  См.
         TDialog для отдельных элементов.

               32  33  34  35  36  37  38  39  40
             ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
CColor       ║$17│$1F│$1A│$31│$31│$31│$1E│$71│$00║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CBlackWhite  ║$07│$0F│$07│$70│$70│$70│$07│$70│$00║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CMonochrome  ║$07│$0F│$07│$70│$70│$70│$07│$70│$00║
             ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
Рамка пассивна ┘   │   │   │   │   │   │   │   └── Короткая метка
Рамка активна ─────┘   │   │   │   │   │   └─ Подсвеченная метка
Кнопка рамки ──────────┘   │   │   │   └───── Нормальная метка
Страница скроллинга ───────┘   │   └───────── Статический текст
Элементы управления ───────────┘
скроллинга



               41  42  43  44  45  46  47  48  49
             ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
CColor       ║$17│$1F│$1A│$31│$31│$31│$1E│$71│$00║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CBlackWhite  ║$07│$0F│$07│$70│$70│$70│$07│$70│$00║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CMonochrome  ║$07│$0F│$07│$70│$70│$70│$07│$70│$00║
             ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
Нормальная кнопка  │   │   │   │   │   │   │   └── Короткий кластер
Кнопка по умолчанию┘   │   │   │   │   │   └───── Выбранный кластер
Выбранная кнопка───────┘   │   │   │   └──────── Нормальный кластер
Запрещенная кнопка─────────┘   │   └──────────── Тень кнопки
Короткая кнопка ───────────────┘



                     50  51  52  53  54  55  56
                   ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╗
CColor             ║$1F│$2F│$1A│$20│$72│$31│$31║
                   ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                   ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CBlackWhite        ║$0F│$70│$0F│$07│$70│$70│$70║
                   ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                   ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CMonochrome        ║$07│$70│$07│$07│$70│$07│$07║
                   ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
Нормальная строка────┘   │   │   │   │   │   └─ Элементы управления
ввода                    │   │   │   │   │  скроллинга окна истории
Выбранная строка   ──────┘   │   │   │   └───── Страница скроллинга
ввода                        │   │   │          окна истории
Стрелки строки ввода ────────┘   │   └────────── Стороны истории
Стрелка истории ─────────────────┘


                     57  58  59  60  61  62  63
                   ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╗
CColor             ║$30│$2F│$3E│$31│$13│$00│$00║
                   ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                   ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CBlackWhite        ║$07│$70│$0F│$07│$07│$00│$00║
                   ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                   ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CMonochrome        ║$07│$70│$0F│$07│$07│$00│$00║
                   ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
Нормальный просмотр──┘   │   │   │   │   │   └── Зарезервировано
списка                   │   │   │   │   │
Активный просмотр  ──────┘   │   │   │   └────── Зарезервировано
списка                       │   │   │
Выбранный просмотр списка ───┘   │   └────────── Информационная
Разделитель просмотра списка ────┘               панель


TRadioButtons                                               Dialogs
═══════════════════════════════════════════════════════════════════

                  ┌────────────┐
                  │   TObject  │
                  └──────┬─────┘
                  ┌──────┴─────┐
                  │    TView   │
                  └──────┬─────┘
                  ┌──────┴─────┐
                  │  TCluster  │
                  └────┬───┬───┘
              ┌────────┘   └──────┐
       ╔══════╧════════╗   ┌──────┴──────┐
       ║ TRadioButtons ║   │ TCheckBoxes │
       ╚═══════════════╝   └─────────────┘

         Объекты TRadioButtons - это кластеры, содержащие до 65,536
         элементов управления,  из которых в любой  момент  времени
         может быть  выбрана только одна кнопка.  Выбор невыбранной
         кнопки будет  автоматически   освобождать   предварительно
         выбранную кнопку.   Этот   объект  наследует  от  TCluster
         большую часть  функций,  включая  Init,   Load   и   Done.
         Зависимые кнопки часто ассоциированы с объектом TLabel.
         TRadioButtons интерпретирует       наследуемое        поле
         TCluster.Value как   номер  "нажатой"  кнопки.  С  номером
         первой кнопки в кластере, равным 0.

 Методы ───────────────────────────────────────────────────────────

 Draw    procedure Draw; virtual;             Перекрывается: Редко
         Рисует кнопки как ' ( ) ' .

 Mark    function Mark(Item: Integer): Boolean; virtual;
                                             Перекрывается: Никогда
         Возвращает True,  если  Item = Value,  т.е.  если кнопка с
         номером Item представлена текущим значением поля Value.

         См. так же: TCluster.Value, TCluster.Mark

 MovedTo procedure MovedTo(Item: Integer); virtual;
                                             Перекрывается: Никогда
         Присваивает Value значение Item.

         См. так же: TCluster.MovedTo, TRadioButtons.Mark

 Press   procedure Press(Item: Integer); virtual;
                                             Перекрывается: Никогда
         Присваивает Value значение Item.  Вызывается  при  нажатии
         кнопки с номером Item.

 SetData procedure SetData(var Rec); virtual;  Перекрывается: Редко
         Вызывает TCluster.SetData для установки поля  Value, затем
         устанавливает поле  Sel равным Value,  поскольку выбранный
         элемент - это "нажатая" кнопка.

         См. так же: TCluster.SetData


Палитра ───────────────────────────────────────────────────────────

         Объекты TRadioButtons  используют  CCluster  -  палитру по
         умолчанию для  всех  объектов  кластера  для   отображения
         элементов с 16 по 18 в палитру стандартного диалога.

                     1    2    3    4
                  ╔════╤════╤════╤════╗
      CCluster    ║ 16 │ 17 │ 18 │ 18 ║
                  ╚══╤═╧══╤═╧══╤═╧══╤═╝
    Нормальный текст      │    │    └─── Короткая выбранная
    Выбранный текст ──────┘    └──────── Короткая нормальная


TRect                                                       Objects
═══════════════════════════════════════════════════════════════════

Поля ─────────────────────────────────────────────────────────────

 A       A: TPoint
         А -   это   точка,   определяющая   верхний   левый   угол
         прямоугольника на экране.

 B       B: Point
         В -   это   точка,   определяющая   нижний   правый   угол
         прямоугольника на экране.

 Методы ───────────────────────────────────────────────────────────

 Assign  procedure Assign(XA, YA, XB, YB: Integer);
         Этот метод    назначает    значения    параметров    полям
         прямоугольника. ХА  становится  А.Х,  ХВ  становится Х.В и
         т.д.

 Copy    procedure Copy(R: TRect);
         Copy устанавливает все поля равными прямоугольнику R.

 Move    procedure Move(ADX, ADY: Integer);
         Перемещает прямоугольник,  добавляя ADX  к  A.X  и  B.X  и
         добавляя ADY к A.Y и B.Y.

 Grow    procedure Grow(ADX, ADY: Integer);
         Изменяет размер  прямоугольника,  вычитая  ADX   из   A.X,
         добавляя ADX к B.X, вычитая ADY из A.Y и добавляя ADY к B.
         Y.

 Intersect procedure Intersect(R: TRect);
         Изменяет положение  и  размер  прямоугольника  до области,
         определенной пересечением текущего положения и R.

 Union   procedure Union(R: TRect);
         Изменяет прямоугольник     до     его     объединения    с
         прямоугольником R;  т.е.  до  наименьшего  прямоугольника,
         содержащего этот объект и R.

 Contains function Contains(P: TPoint): Boolean;
         Возвращает True, если прямоугольник содержит точку P.

 Equals  function Equals(R: TRect): Boolean;
         Возвращает True, если R равен данному прямоугольнику.

 Empty   function Empty: Boolean;
         Возвращает True,  если  прямоугольник  пустой,   т.е.   не
         содержит символьного пространства.  Таким образом поля A и
         B равны.


TResourceCollection                                         Objects
═══════════════════════════════════════════════════════════════════

                  ┌─────────┐
                  │ TObject │
                  └────┬────┘
                ┌──────┴──────┐
                │ TCollection │
                └──────┬──────┘
              ┌────────┴──────────┐
              │ TSortedCollection │
              └────────┬──────────┘
              ┌────────┴──────────┐
              │ TStringCollection │
              └────────┬──────────┘
             ╔═════════╧═══════════╗
             ║ TResourceCollection ║
             ╚═════════════════════╝

         TResourseCollection порожден   от   TStringCollection    и
         используется с   TSourseFile   для   реализации  коллекции
         ресурсов. Файл ресурсов - это поток, который индексируется
         ключевыми строками.  Следовательно, каждый элемент ресурса
         имеет целое поле Pos  и  строковое  поле  Key.  Перекрытие
         методов TResourseCollection   главным  образом  связано  с
         обработкой дополнительных строк в его элементах.
         TResourseCollection используется      внутри      объектов
         TResourseFile для поддержки индекса файла ресурсов.


TResourceFile                                               Objects
═══════════════════════════════════════════════════════════════════

                    ┌─────────┐
                    │ TObject │
                    └────┬────┘
                 ╔═══════╧═══════╗
                 ║ TResourceFile ║
                 ╚═══════════════╝

         TResourseFile реализует      поток,      который     может
         индексироваться ключевыми    строками.    Когда    объекты
         сохраняются в файле ресурса,  используя TResourseFile.Put,
         задается ключевая  строка,  которая  идентифицирует   этот
         объект. Объект  может  быть  позже  получен указанием этой
         ключевой строки в вызове TResourseFile.Get.
         Для обеспечения   быстрого   и   эффективного   доступа  к
         объектам, хранящимся в файле ресурса, TResourseFile хранит
         ключевые   строки   в   отсортированной   коллекции  строк
         (используя тип TResourseCollection) вместе  с  позицией  и
         размером  данных  этого  ресурса в файле ресурса.  Как и в
         случае потоков,  типы объектов, записываемые и читаемые из
         файла  ресурсов,  должны  быть  зарегистрированы с помощью
         RegisterType.

Поля ─────────────────────────────────────────────────────────────

 Stream  Stream: PStream;                            Только чтение
         Указатель на поток, связанный с этим файлом ресурса.

 Modified Modified: Boolean;                         Чтение/Запись
         Установлен в True, если файл ресурса был модифицирован.

Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(AStream: Pstream); Перекрывается: Никогда
         Инициализирует файл  ресурса,  используя  поток,  заданный
         через AStream,  и устанавливает  поле  Modified  в  False.
         Например:

         ResFile.Init(New(TBufStream, Init("MYAPP.RES', stOpenRead,
                      1024)));

         Во время инициализации  Init  смотрит  в  заголовке  файла
         ресурсов текущую позицию в потоке.  Формат заголовка файла
         ресурсов:

         type
           TResFileHeader = record
             Signature: array[1..4] of Char;
             ResFileSize: Longint;
             IndexOffset: Longint;
           end;

         где Signature содержит 'FBPR', ResFileSize содержит размер
         всего файла ресурсов,  за исключением  полей  Signature  и
         ResFileSize (т.е.   размер   файла   ресурса  -8  байт)  и
         IndexOffset содержит смещение коллекции индексов от начала
         заголовка.
         Если Init не находит заголовка  файла  ресурса  в  текущей
         позиции AStream,  он  считает,  что  создается  новый файл
         ресурса и создает пустой индекс.
         Если Init видит метку .EXE файла в текущей позиции потока,
         он просматривает  поток  до  конца  файла  .EXE   и   ищет
         заголовок файла   ресурса  здесь.  Аналогично  Init  будет
         пропускать оверлейный файл,  добавленный к .EXE файлу (так
         же как OvrInit пропускает файл ресурса). Это означает, что
         Вы можете добавить оверлейный файл и файл ресурса (в любом
         порядке) в  конец .EXE файла Вашей программы.  (Именно это
         сделано с выполнимым файлом IDE - TURBO.EXE).

         См. так же: TResourceFile.Done

 Done    destructor Done; virtual;           Перекрывается: Никогда
         Выталкивает файл  ресурса,  используя TResourseFile.Flush,
         затем освобождает индекс и поток, указанный полем Stream.

         См. так же: TResourceFile.Init, TResourceFile.Flush

 Count   function Count: Integer;
         Возвращает число ресурсов, запомненных в файле ресурсов.

         См. так же: TResourceFile.KeyOf

 Delete  procedure Delete(Key: String);
         Удаляет ресурс,  индексируемый   ключем   Key   из   файла
         ресурсов. Пространство,  ранее занятое удаленным ресурсом,
         не используется.  Вы можете удалить эту память,  используя
         SwitchTo для  создания  упакованной  копии  файла  в новом
         потоке.

         См. так же: TResourceFile.SwitchTo

 Flush   procedure Flush;
         Если файл  ресурса  был  модифицирован  (проверяется  поле
         Modified) Flush  сохраняет  обновленный  индекс  в   конце
         потока и  обновляет  заголовок  ресурса  в  начале потока.
         Затем Modified устанавливается в False.

         См. так же: TResourceFile.Done, TResourceFile.Modified

 Get     function Get(Key: String): PObject;
         Ищет Key  в индексе файла ресурсов.  Возвращает nil,  если
         ключ не найден.  Иначе,  устанавливает поток  на  позицию,
         заданную индексом  и  вызывает  Stream^.Get для создания и
         загрузки объекта по этому индексу. Например

         DeskTop^.Insert(ValidView(ResFile.Get('EditorWindow')));

         См. так же: TResourceFile.KeyAt, TResourceFile.Put

 KeyAt   function KeyAt(I: Integer): String;
         Возвращает ключевую строку для ресурса с номером i в файле
         ресурса. Индекс первого  ресурса  0  и  индекс  последнего
         ресурса TResourseFile.Count-1.  Используя Count и KeyAt Вы
         можете обработать все ресурсы в файле ресурса.

         См. так же: TResourceFile.Count

 Put     procedure Put(Item: PObject; Key: String);
         Добавляет объект,  заданный  через  Р  в  файл  ресурса  с
         ключевой строкой,  заданной в Key.  Если  индекс  содержит
         Key, новый  объект  замещает старый.  Объект добавляется в
         конец существующих объектов файла ресурса с использованием
         Stream^.Put

         См. так же: TResourceFile.Get

 SwitchTo  function  SwitchTo(AStream:   PStream;  Pack:  Boolean):
                             PStream;
         Переключает файл ресурса из его потока в поток, переданный
         через AStream и возвращает указатель на новый поток.
         Если параметр  Pack  равен  True,  поток будет отбрасывать
         пустое и неиспользуемое пространство из файла  ресурса  до
         записи в  новый поток.  Это единственный способ сжать файл
         ресурса. Копирование  с  параметром  Pack  =  False  будет
         выполняться быстрее, но без сжатия.


TScrollBar                                                    Views
═══════════════════════════════════════════════════════════════════

                   ┌─────────┐
                   │ TObject │
                   └────┬────┘
                    ┌───┴───┐
                    │ TView │
                    └───┬───┘
                 ╔══════╧═════╗
                 ║ TScrollBar ║
                 ╚════════════╝


Поля ─────────────────────────────────────────────────────────────

 Value   Value : Integer;                             Только чтение
         Поле Value  представляет текущую позицию индикатора полосы
         скроллинга. Этот маркер выделенный цветом, перемещается по
         полосе    скроллинга,   указывая   относительную   позицию
         (горизонтальную или вертикальную в зависимости  от  полосы
         скроллинга) в тексте относительно всего текста, доступного
         для скроллинга.  Многие события могут прямо  или  косвенно
         изменять    Value    такие,    как   отметки   мышкой   на
         элементах полосы скроллинга,  изменение размера  окна  или
         изменение текста в скроллере. Аналогично изменения в Value
         могут потребовать отображение в  события.  TScroolBar.Init
         устанавливает Value в 0.

         См. так   же:  TScrollBar.SetValue,  TScrollBar.SetParams,
         TScrollBar.ScrollDraw,              TScroller.HandleEvent,
         TScrollBar.Init

 Min     Min: Integer;                                Только чтение
         Min представляет  минимальное  значение  поля  Value.   По
         умолчанию TScrollBar устанавливает Min в 0.

         См. так же: TScrollBar.SetRange, TScrollBar.SetParams

 Max     Max: Integer;                                Только чтение
         Max представляет  максимальное  значение  поля  Value.  По
         умолчанию TScrollBar устанавливает Max в 0.

         См. так же: TScrollBar.SetRange, TScrollBar.SetParams

 PgStep  PgStep: Integer;                             Только чтение
         PgStep - это количество добавляемое или вычитаемое из поля
         Value полосы скроллинга,  когда событие от мышки возникает
         в любой части области страницы  (sbPageLeft,  sbPageRight,
         sbPageUp, sbPageDown)   или   обнаруженные   эквивалентные
         клавиши (Ctrl-Ў,  Ctrl-ў,  PgUp,   PgDn).   По   умолчанию
         TScrollBar.Init устанавливает  PgStep  в  1.  PgStep может
         изменяться при      использовании      TScrollBar.SetStep,
         TScrollBar.SetParams и TScroller.SetLimit.

         См. так  же:   TScrollBar.SetStep,   TScrollBar.SetParams,
         TScroller.SetLimit, TScrollBar.ScrollStep

 ArStep  ArStep: Integer;                             Только чтение
         ArStep - это количество добавляемое или вычитаемое из поля
         Value полосы скроллинга  когда  отмечена  область  стрелок
         (sbLeftArrow, sbRightArrow,  sbUpArrow,  sbDownArrow)  или
         обнаружены эквивалентные  нажатия  клавиш.  По   умолчанию
         TScrollBar,Init устанавливает ArStep в 1.

         См. так   же:   TScrolBar.SetStep,    TScrollBar.SetParam,
         TScrollBarScrollStep


Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(var Bounds: TRect);
         Создает и инициализирует  полосу  скроллинга  с  границами
         Bounds, вызывая    TView.Init.    Value,    Max    и   Min
         устанавливаются в 0.  PgStep и ArStep устанавливаются в 1.
         Формы элементов    полосы    скроллинга    по    умолчанию
         устанавливаются в TScrollChars.
         Если Bounds  задает  Size.X = 1,  Вы получите вертикальную
         полосу скроллинга,  иначе -  горизонтальную.  Вертикальные
         полосы скроллинга  имеют  поле  GrowMode,  установленное в
         gfGrowLoX + gfGrowHiX  +  gfGrowHiY;  вертикальные  полосы
         скроллинга имеют поле GrowMode,  установленное gfGrowLoY +
         gfGrouHiX + gfGrowHiY.

 Load    constructor Load(var S: TStream);
         Создает и загружает полосу скроллинга из потока S, вызывая
         TView.Load, затем  читая  5  целочисленных   полей   через
         S.Read.

         См. так же: TScrollBar.Store

 Draw    procedure Draw; virtual;            Перекрывается: Никогда
         Рисует полосу скроллинга в зависимости от  текущих Bounds,
         Value и палитры.

         См. так же: TScrollBar.ScrollDraw, TScrollBar.Value

 GetPalette function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель  на CScrollBar,  палитру по умолчанию
         для полосы скроллинга.

 HandleEvent procedure HandleEvent(var Event: TEvent); virtual;
                                             Перекрывается: Никогда
         Обрабатывает события    полосы     скроллинга,     вызывая
         TView.HandleEvent, затем анализируя Event.What. События от
         мышки - это общие сообщения  владельцу  полосы  скроллинга
         (см. функцию   Message),   которые  должны  обрабатываться
         неявными изменениями полосы скроллинга, например скроллинг
         текста. TScrollBar.HandleEvent  так  же определяет,  какая
         часть полосы скроллинга получила  отметку  от  мышки  (или
         эквивалентную клавишу).   Поле   Value   настраивается   в
         соответствии с  текущими  значениями  ArStep  и  PgStep  и
         индикатор полосы скроллинга перерисовывается.

         См. так же: TView.HandleEvent

 ScrollDraw procedure ScrollDraw; virtual;     Перекрывается: Редко
         ScrollDraw вызывается  при  изменении  поля  Value.   Этот
         псевдоабстрактный метод   вызывается  передачей  сообщения
         cmScrollBarChanged владельцу полосы скроллинга:

         Message(Owner, evBoadcast, cmScrollBarChanged, @Self);

         См. так же: TScrollBar.Value, Message функция

 ScrollStep function ScrollStep(Part: Integer): Integer; virtual;
                                             Перекрывается: Никогда
         По умолчанию  ScrollStep  возвращает   положительное   или
         отрицательное значение  шага в зависимости от части полосы
         скроллинга,  заданной в Part и текущих значений  ArStep  и
         PgStep. Аргумент Part должен быть одной из констант sbXXXX
         описанных в главе 14.

         См. так же: TScrollBar.SetStep, TScrollBar.SetParams

 SetParams procedure SetParams(AValue,AMin, AMax, APgStep, AArStep:
                              Integer);
         SetParams устанавливает поля Value,  Min,  Max,  PgStep  и
         ArStep в  заданные  значения.  Если аргументы конфликтуют,
         выполняются согласования.  Например,  Min  не  может  быть
         больше Max,  поэтому если AMax < AMin, Max устанавливается
         в Min.  Value  должно  лежать  в  диапазоне  [Min,   Max],
         поэтому, если  Value < AMin,  Value устанавливается в Min;
         если AValue > AMax,  Value устанавливается в Max. DrawView
         перерисовывает полосу  скроллинга.  Если Value изменяется,
         будет вызвана ScroolDraw.

         См. так   же:    TView.DrawView,    TScrollBar.ScrollDraw,
         TScrollBar.SetRange, TScrollBar.SetValue

 SetRange procedure SetRange(AMin, AMax: Integer);
         SetRange задает  допустимый  диапазон  для   поля   Value,
         устанавливая Min  и  Max в AMin и AMax.  SetRange вызывает
         SetParams, поэтому DrawView и ScroolBar  будут вызываться,
         если изменения требуют перерисовки полосы скроллинга.

         См. так же: TScrollBar.SetParams

 SetStep procedure SetStep(APgStep, AArStep: Integer);
         SetStep устанавливает поля PgStep и ASrStep  в  APgStep  и
         AArStep. Этот   метод   вызывает  SetParams  с  остальными
         аргументами, равными их текущим значениям.

         См. так же: TScrollBar.SetParams, TScrollBar.ScrollStep

 SetValue procedure SetValue(AValue: Integer);
         SetValue устанавливает   поле   Value  в  AValue,  вызывая
         SetParams с остальными аргументами,  установленными  в  их
         текущие значения.  DrawView и ScrollDraw вызываются,  если
         этот вызов изменяет значение Value.

         См. так   же:   TScroll   Bar.SetParams,   TView.DrawView,
         TScrollBar.ScrollDraw, TScroller.ScrollTo

 Store   procedure Store(var S:TStream);
         Сохраняет объект   TScrollBar   в   потоке   S,    вызывая
         TView.Store, затем   записывая  5  целочисленных  полей  в
         поток, используя S.Write.

         См. так же: TScrollBar.Load


Палитра ───────────────────────────────────────────────────────────

         Объекты полосы  скроллинга используют палитру по умолчанию
         CScrollBar для отображения в  4  и  5-й  элементы  палитры
         стандартной программы.

                        1   2   3
                      ╔═══╤═══╤═══╗
         CScrollBar   ║ 4 │ 5 │ 5 ║
                      ╚═╤═╧═╤═╧═╤═╝
         Страница ──────┘   │   └───── Индикатор
         Стрелки ───────────┘


TScroller                                                     Views
═══════════════════════════════════════════════════════════════════

                     ┌─────────┐
                     │ TObject │
                     └────┬────┘
                     ┌────┴────┐
                     │  TView  │
                     └────┬────┘
                    ╔═════╧═════╗
                    ║ TScroller ║
                    ╚═════╤═════╝
                   ┌──────┴──────┐
                   │ TTextDevice │
                   └──────┬──────┘
                    ┌─────┴─────┐
                    │ TTerminal │
                    └───────────┘


Поля ─────────────────────────────────────────────────────────────

 HScrollBar  HScrollBar:PScrollBar;                  Только чтение
         Указывает на горизонтальную полосу скроллинга, связанную с
         этим скроллером.  Если  такой   полосы   скроллинга   нет,
         HScroolBar равен nil.

 VScrollBar  VScrollBar: PScrollBar;                 Только чтение
         Указывает на вертикальную полосу скроллинга,  связанную  с
         этим   скроллером.   Если  такой  полосы  скроллинга  нет,
         VScroolBar равен nil.

 Delta   Delta: TPoint;                              Только чтение
         Содержит Х  (горизонтальная) и Y (вертикальная) компоненты
         позиции скроллера   относительно   вирутального   видимого
         элемента. Автоматический  скроллинг достигается изменением
         одной или обоих компонент в ответ,  например,  на  события
         полосы скроллинга,  изменяющих значения поля Value. Ручной
         скроллинг изменяет  Delta,  отображает  изменения  в  поле
         Value полосы    скроллинга   и   приводит   к   обновлению
         индикаторов полосы скроллинга.

         См. так же: TScroller.ScrollDraw, TScroller.ScrollTo

 Limit   Limit: TPoint;                              Только чтение
         Limit.X Limit.Y  - это максимально допустимые значения для
         Delta.X и Delta.Y.

         См. так же: TScroller.Delta


Методы ───────────────────────────────────────────────────────────

 Init    constructor    Init(var   Bounds:   TRect;   AHScrollBar,
                            AVScrollBar: PScrollBar);
         Создает и   инициализирует  объект  TScroller  с  заданным
         размером и полосами скроллинга.  Вызывает  TView.Init  для
         установки размера      видимого      элемента.     Options
         устанавливается в     ofSelectabble,      а      EventMask
         устанавливается в  evBroadcast.  AHScrollBar  должен  быть
         nil, если Вы не хотите горизонтальную  полосу  скроллинга;
         аналогично AVScrollBar должен быть nil,  если Вы не хотите
         вертикальной полосы скроллинга.

         См. так же: TView.Init, TView.Options, TView.EventMask

 Load    constructor Load(var S: TStream);
         Загружает видимый  элемент скроллера из потока S,  вызывая
         TView.Load, затем  восстанавливает  указатели  на   полосы
         скроллинга, используя GetPeerViewPtr и читает поля Delta и
         Limit, используя S.Read.

         См. так же: TScroller.Store

 ChangeBounds procedure ChangeBounds(var Bounds: TRect); virtual;
                                             Перекрывается: Никогда
         Изменяет размер   скроллера,   вызывая   SetBounds.   Если
         необходимо, скроллер  и полосы скроллинга перерисовываются
         вызовом DrawView и SetLimit.

         См. так     же:      TView.SetBounds,      TView.DrawView,
         TScroller.SetLimit

 GetPalette  function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель  на  палитру  скроллера  по умолчанию
         CScroller.

 HandleEvent  procedure HandleEvent(var Event: TEvent); virtual;
                                               Перекрывается: Редко
         Обрабатывает большинство         событий,          вызывая
         TView.HandleEvent. Общие      события      с      командой
         cmScrollBarChanged, если  они  пришли  от  HScrollBar  или
         VScrollBar, приводят к вызову TScroller.ScrollDraw.

         См. так же: TView.HandleEvent, TScroller.ScrollDraw

 ScrollDraw  procedure ScrollDraw; virtual;  Перекрывается: Никогда
         Проверяет, соответствует ли Delta соответствующим позициям
         полос скроллинга.  Если  нет  -  Delta  устанавливается  в
         корректное значение и вызывается DrawView  для перерисовки
         скроллера.

         См. так      же:      TView.DrawView,     TScroller.Delta,
         TScroller.HscrollBar, TScroller.VScrollBar

 ScrollTo  procedure ScrollTo(X, Y: Integer);
         Устанавливает полосы   скроллинга   в   (X,   Y),  вызывая
         HScrollBar^.SetValue(X) и    VScrollBar^.SetValue(Y)     и
         перерисовывает видимый элемент, вызывая DrawView.

         См. так же: TView.DrawView, TScroller.SetValue

 SetLimit  procedure SetLimit(X, Y: Integer);
         Устанавливает Limit.X в X и Limit.Y в  Y,  затем  вызывает
         HScrollBar^.SetParams и  VScrollVar^.SetParams  (если  эти
         полосы скроллинга существуют),  чтобы  настроить  их  поля
         Max. Эти   вызовы  могут  привести  к  перерисовке  полосы
         скроллинга. Наконец вызывается  DrawView  для  перерисовки
         скроллера, если это необходимо.

         См. так    же:    TScroller.Limit,    TScroller.HScroller,
         TScroller.VScrollBar, TScrollBar.SetParams

 SetState  procedure   SetState(AState:  Word;   Enable:  Boolean);
         virtual;                              Перекрывается: Редко
         Этот метод вызывается при изменении  состояния  скроллера.
         Вызов TView.SetState   устанавливает   или  очищает  флаги
         состояния в State.  Если новое состояние  -  sfSelected  и
         sfActive, SetState отображает полосы скроллинга, иначе они
         скрываются.

 Store procedure Store(var S: TStream);
         Записывает скроллер в поток S,  вызывая TView.Store, затем
         сохраняет ссылки   на   полосы    скроллинга,    используя
         PutPeerViewPtr, наконец записывает значения Delta и Limit,
         используя S.Write.

         См. так же: TScroller.Load, TStream.Write

 Палитра───────────────────────────────────────────────────────────

         Объекты скроллера   используют   палитру   по    умолчанию
         CScroller для   отображения  в  6  и  7  элементы  палитры
         стандартной программы.

                       1   2
                     ╔═══╤═══╗
         CScroller   ║ 6 │ 7 ║
                     ╚═╤═╧═╤═╝
         Нормальный ───┘   └──── Подсвеченный


 TSortedCollection                                          Objects
═══════════════════════════════════════════════════════════════════

                  ┌─────────┐
                  │ TObject │
                  └────┬────┘
                ┌──────┴──────┐
                │ TCollection │
                └──────┬──────┘
              ╔════════╧══════════╗
              ║ TSortedCollection ║
              ╚════════╤══════════╝
              ┌────────┴──────────┐
              │ TStringCollection │
              └────────┬──────────┘
             ┌─────────┴───────────┐
             │ TResourceCollection │
             └─────────────────────┘

         TSortedCollection порожден  от  TCollection  и   реализует
         коллекцию, отсортированную   по  ключу  без  дублирования.
         Сортировка производится методом TStringCollection.Compare,
         который Вы  перекрываете,  чтобы  задать  свое определение
         упорядочивания элементов.     Когда     новые     элементы
         добавляются, они   автоматически   втавляются  в  порядке,
         заданном методом Compare.  Элементы  будут  располагаться,
         используя двоичный метод  поиска TStringCollection.Search.
         Виртуальный   метод   KeyOf,  возвращающий  указатель  для
         Compare,  так же может быть перекрыт, если Compare требует
         дополнительной информации.


Методы ───────────────────────────────────────────────────────────

 Compare  function Compare(Key1, Key2: Pointer): Integer; virtual;
                                             Перекрывается: Всегда
         Compare -  это  абстрактный  метод,  который  должен  быть
         перекрыт во   всех   порожденных   типах.  Compare  должен
         сравнивать 2 ключевых значения и возвращать результат:

     ────────────────────────────────────────────
          -1   if Key1 < Key2
           0   if Key1 = Key2
           1   if Key1 > Key2
     ────────────────────────────────────────────

         Key1 и  Key2  -  это  значения указателей,  извлеченных из
         соответствующей коллеции         элементов         методом
         TSortedCollection.KeyOf. Метод    TSortedCollection.Search
         реализует двоичный поиск  элементов  коллекции,  используя
         Compare для сравнения элементов.

         См. так же:    TSortedCollection.KeyOf,
                        TSortedCollection.Compare

 IndexOf  function IndexOf(Item: Pointer): Integer; virtual;
                                             Перекрывается: Никогда
         Использует TSortedCollection.Search для нахождения индекса
         элемента Item.   Если  элемент  не  в  коллекции,  IndexOf
         возвращает -1. Реализация TSortedCollection.IndexOf:

         if Search(KeyOf(Item), I) then IndexOf := I
         else IndexOf := -1;

         См. так же: TSortedCollection.Search

 Insert  procedure Insert(Item: Pointer); virtual;
                                             Перекрывается: Никогда
         Если элемент  не  найден  в  коллекции,  он  вставляется в
         позицию, определенную          индексом,          вызывает
         TSortedCollection.Search для  определения,  существует  ли
         элемент. Если   нет,   куда   вставить   его.   Реализация
         TSortedCollection.Insert:

         if nоt Search(KeyOf(Item), I) then AtInsert(I, Item)

         См. так же: TSortedCollection.Search

 KeyOf   function KeyOf(Item: Pointer): Pointer; virtual;
                                              Перекрывается: Иногда
         Для данного    элемента    коллекции    KeyOf   возвращает
         соответствующий ключ      элемента.      По      умолчанию
         TSortedCollection.KeyOf просто   возвращает   Item.  KeyOf
         перекрывается в случае, когда ключ элемента не совпадает с
         элементом.

         См. так же: TSortedCollection.IndexOf

 Search function Search(Key: Pointer; var Index: Integer): Boolean;
                       virtual;                Перекрывается: Редко
         Возвращает True,  если  элемент,  заданный ключем Key,  не
         найден в отсортированной коллекции.  Если элемент  найден,
         Index устанавливается  в  найденный  индекс;  иначе  Index
         устанавливается в индекс,  куда будет  помещаться  элемент
         при вставке.

         См. так           же:           TSortedCollection.Compare,
         TSortedCollection.Insert


TStaticText                                                 Dialogs
═══════════════════════════════════════════════════════════════════

                  ┌─────────┐
                  │ TObject │
                  └────┬────┘
                   ┌───┴───┐
                   │ TView │
                   └───┬───┘
                ╔══════╧══════╗
                ║ TStaticText ║
                ╚══════╤══════╝
                   ┌───┴────┐
                   │ TLabel │
                   └────────┘

         Объекты TStaticText   представляют   простейшие    видимые
         элементы: они  содержат  фиксированный  текст и игнорируют
         все события, переданные им. Они используются как сообщения
         или  пассивные  метки.  Наследники  TStaticText  выполняют
         более активную роль.

Поля ─────────────────────────────────────────────────────────────

 Text    Text: PString;                              Только чтение
         Указатель на   строку   текста,   отображаемую  в  видимом
         элементе.


Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(var Bounds: TRect; AText: String);
         Создает объект  StaticText  заданного   размера,   вызывая
         TView.Init, затем устанавливая текст в NewStr(AText).

         См. так же: TView.Init

 Load    constructor Load(varS: TStream);
         Создает и инициализирует  объект  TStaticText  из  данного
         потока. Вызывает   TView.Load   и  устанавливает  текст  с
         помощью S.ReadStr.      Используется      совместно      с
         TStaticText.Store для  сохранения  и  чтения  статического
         текстового видимого элемента из потока.

         См. так же: TViewLoad, TStaticText.Store, TStream.ReadStr

 Done    destructor Done; virtual;             Перекрывается: Редко
         Освобождает строку  Text,  затем  вызывает  TView.Done для
         разрушения объекта.

 Draw    procedure Draw; virtual;              Перекрывается: Редко
         Рисует строку  текста внутри видимого элемента,  слово при
         необходимости переносится.  Ctrl-M в тексте  указывает  на
         начало новой строки.  Если строка начинается с Ctrl-C, она
         центрируется в видимом элементе.

 GetPalette  function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель на палитру по умолчанию CStaticText.

 GetText  procedure GetText(varS: String); virtual;
                                              Перекрывается: Иногда
         Возвращает в S строку, на которую указывает Text.

 Store   procedure TStaticText.Store(var S: TStream);
         Сохраняет объект TStaticText в потоке, вызывая TView.Store
         и S.WriteStr.  Используется совместно с  TStaticText.Store
         для сохранения  и  чтения статического текстового видимого
         элемента из потока.

         См. так же: TStaticText.Load, TView.Store, TStream.WriteStr


Палитра ───────────────────────────────────────────────────────────

         Статический текст    использует   палитру   по   умолчанию
         CStaticText для  отображения   в   6-й   элемент   палитры
         стандартного диалога.

                             1
                           ╔═══╗
              CStaticText  ║ 6 ║
                           ╚═╤═╝
              Цвет текста ───┘


TStatusLine                                                   Menus
═══════════════════════════════════════════════════════════════════

                     ┌─────────┐
                     │ TObject │
                     └────┬────┘
                     ┌────┴────┐
                     │  TView  │
                     └────┬────┘
                   ╔══════╧══════╗
                   ║ TStatusLine ║
                   ╚═════════════╝

         Объект TStatusLine   -   это   видимый   элемент,   обычно
         отображаемый внизу   экрана.   Типичная   строка   статуса
         отображает список   доступных  горячих  клавиш,  свободную
         память, время  дня,   текущий   режим   редактирования   и
         подсказки пользователя.        Отображаемые       элементы
         устанавливаются в     связанный     список,      используя
         InitStatusLine в   TApplication   и  отображаемый  элемент
         зависит от контекста подсказки текущего видимого элемента.
         Как и  полоса меню и панель экрана,  строка статуса обычно
         принадлежит группе TApplication.
         Элементы строки  статуса  -  это  записи типа TStatusItem,
         которые содержат поля для текстовой строки, отображаемой в
         строке статуса,   кода   ключа,   связываемого  с  горячей
         клавишей (обычно функциональная клавиша или комбинация Alt
         -клавиша) и команды, генерируемой, если отображаемый текст
         отмечен мышкой или нажата горячая клавиша.
         Строка статуса    отображает    контекстно-ориентированную
         подсказку. Каждый объект строки статуса содержит связанный
         список строк   статуса  Defs  (типа  TStatusDef),  которые
         определяют диапазон   контекстных   подсказок   и   список
         элементов статуса,  отображаемый,  когда  текущий контекст
         подсказки находится в этом диапазоне.  Кроме  того,  может
         отображаться предопределенная   строка  в  соответствии  с
         текущим контекстом подсказки.


Поля ─────────────────────────────────────────────────────────────

 Items   Items: PStatusItem;                         Только чтение
         Указатель на  текущий  связанный   список   записей   типа
         TStatusItem.

         См. так же: TStatusItem

 Defs    Defs: PStatusDef;                           Только чтение
         Указатель на  текущий  связанный   список   записей   типа
         TStatusDef. Список  для использования определяется текущим
         контекстом подсказки.

         См. так      же:      TStatusDef,      TStatusLine.Update,
         TStatusLine.Hint


Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(var Bounds: TRect; ADefs: PStatusDef);
         Создает объект  TStatusLine  с  размером  Bounds,  вызывая
         TView.Init. Бит ofPreProcess  в  Options  устанавливается,
         EventMask устанавливается,  включая evBroadcast и GrowMode
         устанавливается в gfGrowLoY + gfGrowHiX +  gfGrowHiY. Поле
         Defs устанавливается  в  ADefs.  Если  ADefs - nil,  Items
         устанавливается  в   nil,  иначе   Items устанавливается в
         ADefs^.Items.

         См. так же: TView.Init

 Load    constructor Load(var S: TStream);
         Создает объект TStatusLine и загружает его  из  потока  S,
         вызывая TView.Load, затем читая Defs и Items из потока.

         См. так же: TView.Load, TStatusLine.Store

 Done    destructor Done; virtual;           Перекрывается: Никогда
         Освобождает все Items и Defs в объекте  TStatusLine, затем
         вызывает TView.Done.

         См. так же: TView.Done

 Draw    procedure Draw; virtual;              Перекрывается: Редко
         Рисует строку статуса,  выводя  строку  Text  для  каждого
         элемента статуса,  затем  все подсказки,  определенные для
         данного текущего   контекста    подсказки    за    полосой
         разделителя.

         См. так же: TStatusLine.Hint

 GetPalette  function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель на палитру по умолчанию CStatusLine.

 HandleEvent  procedure HandleEvent(var Event: TEvent); virtual;
                                               Перекрывается: Редко
         Обрабатывает события, передаваемые строке статуса, вызывая
         TView.HandleEvent, затем проверяет на 3  вида  специальных
         событий. Отметки    мышкой,    которые   попадают   внутрь
         прямоугольника, занимаемого элементом  статуса, генерируют
         командное событие с Event.What,  установленного в Command,
         для этого  элемента   статуса.   События   от   клавиатуры
         сравниваются с    полем    KeyCode    каждого    элемента;
         соответствие вызывает командное событие  с  Command  этого
         элемента. Общие  события с командой cmCommand,  SetChanged
         заставляют строку  статуса  перерисовывать   себя,   чтобы
         отразить любые   горячие   клавиши,   которые  могут  быть
         разрешены или запрещены.

         См. так же: TView.HandleEvent

 Hint    function Hint(AHelpCtx: Word): String; virtual;
                                               Перекрывается: Часто
         Этот псевдоабстрактный метод возвращает пустую  строку. Он
         должен быть     перекрыт     для     обеспечения    строки
         контекстно-ориентированной подсказки     для     аргумента
         AHelpCtx. Непустая   строка   будет  рисоваться  в  строке
         статуса после полосы разделителя.

         См. так же: TStatusLine.Draw

 Store   procedure Store(var S: TStream);
         Сохраняет объект   TStatusLine   в   потоке   S,   вызывая
         TView.Store, затем записывая все определения статуса  и их
         ассоциированные списки   элементов  в  поток.  Сохраненный
         объект может быть восстановлен используя TStatusLine.Load.

         См. так же: TView.Store, TStatusLine.Load

 Update  procedure Update;
         Выбирает корректный Items из списка Defs. В зависимости от
         текущего контекста подсказки,  затем вызывает DrawView для
         перерисовки строки статуса, если элементы были изменены.

         См. так же: TStatusLine.Defs


Палитра ───────────────────────────────────────────────────────────

         Строки статуса используют палитру по умолчанию CStatusLine
         для отображения   в   элементы  со  2  по  7-й  в  палитре
         стандартной программы.


                  1    2    3    4    5    6
               ╔════╤════╤════╤════╤════╤════╗
CStatusLine    ║  2 │  3 │  4 │  5 │  6 │  7 ║
               ╚══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╝
Нормальный текст ─┘    │    │    │    │    └── Выбранный короткий
Запрещенный текст ─────┘    │    │    └────── Выбранный запрещенный
Короткий текст ─────────────┘    └──────────── Выбранный нормальный


TStream                                                     Objects
═══════════════════════════════════════════════════════════════════

                   ┌───────────┐
                   │  TObject  │
                   └─────┬─────┘
                    ╔════╧════╗
                    ║ TStream ║
                    ╚══╤═══╤══╝
               ┌───────┘   └──────┐
          ┌────┴───────┐    ┌─────┴──────┐
          │ TDosStream │    │ TEmsStream │
          └────┬───────┘    └────────────┘
          ┌────┴───────┐
          │ TBufStream │
          └────────────┘

         TStream -  это  общий  абстрактный  обект,  обеспечивающий
         полиморфический В/В  в  и/из устройства памяти.  Вы можете
         создать порожденный объект потока,  перекрывая виртуальные
         методы GetPos,  GetSize,  Read,  Seek,  Truncate  и Write.
         Turbo Vision делает это в порожденных потоках TDosStream и
         TEmsStream. Для  порожденного  буферизованного  потока  Вы
         должны так же перекрыть TStream.Flush.

Поля ─────────────────────────────────────────────────────────────

 Status  Status: Integer;                             Чтение/Запись
         Указывает текущий статус потока:

             Таблица 13.1. Коды ошибок потока.

     ─────────────────────────────────────────────────
     Коды ошибок TStream
     ─────────────────────────────────────────────────
     stOk          Нет ошибок
     stError       Ошибка доступа
     stInitError   Нельзя инициализироввать поток
     stReadError   Чтение за концом файла
     stWriteError  Нельзя расширить поток
     stGetError    Get для незарегистрированного типа
     stPutError    Put для незарегистрированного типа
     ─────────────────────────────────────────────────

         Если Status  <>  stOK,  все  операции  над  потоком  будут
         запрещены до тех пор, пока не будет вызван Reset.

 ErrorInfo  ErrorInfo: Integer;                       Чтение/Запись
         Содержит дополнительнительную информацию когда  Status  не
         stOK. Для    значений    Status:   stError,   stInitError,
         stReadError, stWriteError,  ErrorInfo содержит код  ошибки
         DOS или   EMS,   если   такой   существует.  Когда  Status
         stGetError, ErrorInfo  содержит  IDE  типа  объекта  (поле
         ObjType в TStreamRec) не зарегистрированного типа объекта.
         Когда Status - stPutError, ErrorInfo содержит смещение VMT
         в сегменте   данных   (поле   VmtLink   в  TStreamRec)  не
         зарегистрированного типа объекта.


Методы ───────────────────────────────────────────────────────────

 CopyFrom  procedure CopyFrom(var S: TStream; Count: Longint);
         Копирует Count  байт  из  потока  S  в  вызывающий  поток.
         Например:

         NewStream := New(TEmsStream, Init(OldStream^.GetSize));
         OldStream^.Seek(0);
         NewStream^.CopyFrom(OldStream, OldStream^.GetSize);

         См. так же: TStream.GetSize, TObject.Init

 Error   procedure Error(Code, Info: Integer); virtual;
                                              Перекрывается: Иногда
         Вызывается, если  возникла  ошибка  потока.  По  умолчанию
         TStream.Error сохраняет Code  и  Info  в  полях  Status  и
         ErrorInfo. Затем,  если  глобальная переменная StreamError
         не nil,  вызывает процедуру, заданную в StreamError. После
         возникновения ошибки,  все  операции над потоком запрещены
         до тех пор, пока не будет вызван Reset.

         См. так же: TStream.Reset, StreamError переменная

 Flush   procedure Flush; virtual;            Перекрывается: Иногда
         Абстрактный метод,  который должен быть перекрыт, если Ваш
         порожденный тип  реализует   буфер.   Этот   метод   может
         выталкивать любые буфера,  очищая буфер чтения и записывая
         буфер вывода. По умолчанию TStream.Flush ничего не делает.

         См. так же: TDosStream.Flush

 Get     function Get: PObject;
         Читает объект из потока. Объект должен быть предварительно
         записан в поток через TStream.Put.  Get вначале читает  ID
         типа объекта   (слово)   из   потока.   Затем  он  находит
         соответствующий тип объекта,  сравнивая ID с полем ObjType
         всех зарегистрированных    типов    объектов    (см.   тип
         TStreamRec). Наконец вызывает констрактор Load  этого типа
         объекта для  создания  и  загрузки  объекта.  Если ID типа
         объекта, считанного из потока,  равен  0,  Get  возвращает
         указатель nil;  если  ID  типа  объекта не зарегистрирован
         (используя RegisterType)  Get  вызывает  TStream.Error   и
         возвращает указатель  nil;  иначе Get возвращает указатель
         на вновь созданный объект.

         См. так же:  TStream.Put,  RegisterType,  TStreamRec, Load
         методы

 GetPos  function GetPos: Longint; virtual;   Перекрывается: Всегда
         Возвращает текущую  позицию  в  потоке.  Этот  абстрактный
         метод должен всегда перекрываться.

         См. так же: TStream.Seek

 GetSize  function GetSize: Longint; virtual; Перекрывается: Всегда
         Возвращает размер потока.  Это абстрактный метод и  должен
         перекрываться.

 Put     procedure Put(P: PObject);
         Записывает объект в поток.  Объект позже можно считать  из
         потока, используя   TStream.Get.   Put   вначале   находит
         регистрационную запись  типа  этого   объекта,   сравнивая
         смещение VMT     объекта     с    полем    VmtLink    всех
         зарегистрированных типов объектов  (см.  тип  TStreamRec).
         Затем записывает    ID    типа   объекта   (поле   ObjType
         регистрационной записи) в поток,  и наконец вызывает метод
         Store этого типа объекта для записи объекта. Если аргумент
         Р, переданный в Put - nil,  Put записывает в поток  слово,
         содержащее 0.  Если  тип  объекта  в  Р не зарегистрирован
         (испольуя RegisterType),  Put  вызывает  TStream.Error   и
         ничего не пишет в поток.

         См. так же:  TStream.Get,  RegisterType, TStreamRec, Store
         методы

 Read    procedure Read(var Buf; Count: Word); virtual;
                                              Перекрывается: Всегда
         Это абстрактный  метод  и  должен  перекрываться  во  всех
         порожденных типах. Read должен читать Count байт из потока
         в Buf и перемещать текущую позицию потока на  Count  байт.
         Если  произошла  ошибка,  Read  должен  вызывать  Error  и
         заполнять Buf Count байтами, равными 0.

         См. так же: TStream,Write, TStream.Error

 ReadStr  function ReadStr: PString;
         Читает строку   из   текущей   позиции  потока,  возвращая
         указатель PString.  TStream.ReadStr  вызывает  GetMem  для
         распределения (Length+1) байт для строки.

         См. так же: TStream.WriteStr

 Reset   procedure Reset;
         Сбрасывает ошибочное условие потока, устанавливая Status и
         ErrorInfo в   0.   Этот  метод  позволяет  Вам  продолжать
         обработку потока  после  ошибочной  ситуации,  которую  Вы
         скорректировали.

         См. так же: TStream.Status, TStream.ErrorInfo, sfXXXX коды
         ошибок

 Seek  procedure Seek(Pos: Longint); virtual; Перекрывается: Всегда
         Это абстрактный  метод  и  должен  перекрываться  во  всех
         потомках. TStream.Seek устанавливает текущую позицию в Pos
         байт, начиная от начала потока. Начало потока - позиция 0.

         См. так же: TStream.GetPos

 Truncate  procedure Truncate; virtual;       Перекрывается: Всегда
         Это абстрактный  метод  и  должен  перекрываться  во  всех
         потомках. TStream.Truncate  удаляет все данные в потоке от
         текущей позиции до конца.

         См. так же: TStream.GetPos, TStream.Seek

 Write   procedure Write(var Buf; Count: Word); virtual;
                                              Перекрывается: Всегда
         Это абстрактный  метод  и  должен  перекрываться  во  всех
         потомках. Write  записывает  Count  байт  из Buf в поток и
         перемещает текущую позицию  потока  на  Count  байт.  Если
         возникла ошибка, Write должен вызывать Error.

         См. так же: TStream.Read, TStream.Error

 WriteStr  procedure WriteStr(P: PString);
         Записывает строку P^ в поток, начиная с текущей позиции.

         См. так же: TStream.ReadStr


TStringCollection                                           Objects
═══════════════════════════════════════════════════════════════════

                  ┌─────────┐
                  │ TObject │
                  └────┬────┘
                ┌──────┴──────┐
                │ TCollection │
                └──────┬──────┘
              ┌────────┴──────────┐
              │ TSortedCollection │
              └────────┬──────────┘
              ╔════════╧══════════╗
              ║ TStringCollection ║
              ╚════════╤══════════╝
             ┌─────────┴───────────┐
             │ TResourceCollection │
             └─────────────────────┘

         TStringCollection порожден    от    TSortedCollection    и
         реализует сортированный    список   ASCII   строк.   Метод
         TStringCollection.Compare перекрывается    для     задания
         обычного лексикографического  упорядочения строк ASCII. Вы
         можете перекрыть Compare для задания другого упорядочения,
         такого как для неанглийских наборов символов.

Методы ───────────────────────────────────────────────────────────

 Compare  function Compare(Key1, Key2: Pointer): Integer; virtual;
                                              Перекрывается: Иногда
         Сравнивает строки Key1^ и Key2^ : возвращает -1, если Key1
         < Key2; 0, если Key1 = Key2 и +1, если Key1 > Key2.

         См. так же: nTStringCollection.Search

 FreeItem  procedure FreeItem(Item: Pointer); virtual;
                                               Перекрывается: Редко
         Удаляет строку  Item^  из  отсортированной   коллекции   и
         освобождает строку.

 GetItem  function GetItem(var S: TStream): Pointer; virtual;
                                               Перекрывается: Редко
         По умолчанию читает строку из TStream, вызывая SReadStr.

         См. так же: TStream.ReadStr

 PutItem  procedure PutItem(var S: TStream; Item: Pointer);
                           virtual;            Перекрывается: Редко
         По умолчанию записывает строку Item^ в TStream, вызывая S.
         WriteStr.

         См. так же: TStream.WriteStr


TStringList                                                 Objects
═══════════════════════════════════════════════════════════════════

                   ┌───────────┐
                   │  TObject  │
                   └───┬───┬───┘
                ┌──────┘   └──────┐
         ╔══════╧══════╗   ┌──────┴────────┐
         ║ TStringList ║   │ TStrListMaker │
         ╚═════════════╝   └───────────────┘

         TStringList предоставляет механизм для доступа  к строкам,
         хранящимся в  потоке.  Каждая строка,  хранящаяся в списке
         строк идентифицируется уникальным номером (ключем) между 0
         и 65,535. Списки строк занимают меньше памяти, чем обычные
         строки, поскольку строки хранятся в потоке, а не в памяти.
         Кроме того,  списки  строк легко решают проблему настройки
         программ на  языки,  поскольку  строки  не  "встроены"   в
         программу.
         TStringList имеет методы только для доступа к строкам; для
         создания списка     строк     Вы    должны    использовать
         TStrListMaker.
         Заметим, что  TStringList  и  TStrListMaker  имеют один ID
         типа объекта (поле ObjType в TStreamRec)  и следовательно,
         не могут  регистрироваться и использоваться одновременно в
         одной программе.


Методы ───────────────────────────────────────────────────────────

 Load    constructor Load(var S:TStream);
         Загружает индекс списка строк из потока S и  хранит ссылку
         на S так, что TStringLis.Get может обращаться к потоку при
         чтении строк.
         Считая, что  TStringList  был  зарегистрирован,  используя
         RegisterType(RStringList),  здесь  показано,  как  считать
         список строк  (созданный  с использованием TStrListMaker и
         TResourseFile.Put) из файла ресурса:

         ResFile.Init(New(TBufStream, Init('MYAPP.RES', stOpenRead,
                  1024)));
         Strings := PStringList(ResFile.Get('Strings'));

         См. так же: TStrListMaker.Init, TStringList.Get

 Done    destructor Done; virtual;           Перекрывается: Никогда
         Освобождает память, распределенную под список строк.

         См. так же: TStrListMaker.Init, TStringList.Done

 Get     function Get(Key: Word): String;
         Возвращает строку,  заданную через Key, или пустую строку,
         если нет строки с данным Key. Например:

         P := @FileName;
         FormatStr(S, Strings^.Get(sLoadingFile), P);

         См. так же: TStringListMaker.Put


TStrListMaker                                               Objects
═══════════════════════════════════════════════════════════════════

                   ┌───────────┐
                   │  TObject  │
                   └───┬───┬───┘
              ┌────────┘   └──────┐
       ╔══════╧════════╗   ┌──────┴──────┐
       ║ TStrListMaker ║   │ TStringList │
       ╚═══════════════╝   └─────────────┘

         TStrListMaker - это простой тип объекта,  используемый для
         создания списка строк, который используют с TStringList.
         Следующий фрагмент  кода  показывает   как   создавать   и
         сохранять список строк в файле ресурса.

         const
           sInformation = 100;
           sWarning     = 101;
           sError       = 102;
           sLoadingFile = 200;
           sSavingFile  = 201;

         var
           ResFile: TResourceFile;
           S: TStrListMaker;

         begin
           RegisterType(RStrListMaker);
           ResFile.Init(New(TBufStream, Init('MYAPP.RES', stCreate,
                        1024)));
           S.Init(16384, 256);
           S.Put(sInformation, 'Information');
           S.Put(sWarning, 'Warning');
           S.Put(sError, 'Error');
           S.Put(sLoadingFile, 'Loading file #s.');
           S.Put(sSavingFile, 'Saving file #s.');
           ResFile.Put(@S,'Strings');
           S.Done;
           ResFile.Done;
         end;


Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(AStrSize, AIndexSize: Word);
         Создает в  памяти список строк размера AStrSize с индексом
         из AIndexSize элементов.  Буфер  строк  и  буфер  индексов
         заданного размера распределяются в куче.
         AStrSize должен быть достаточно велик  для  хранения  всех
         строк, добавляемых в список строк - каждая строка занимает
         свою длину плюс 1 байт.
         При добавлении    строк    в   список   строк   (используя
         TStrListMaker.Put) строится   индекс   строк.   Строки   с
         последовательными ключами    (такими   как   sInformation,
         sWarning и sError в  предыдущем  примере)  записываются  в
         одну индексную   запись  до  16.  AIndexSize  должен  быть
         достаточно большим  для  добавления  всех  сгенерированных
         индексных записей. Каждый элемент индекса занимает 6 байт.

         См. так же: TStringList.Load, TStrListMaker.Done

 Done    destructor Done; virtual;
         Освобождает память, распределенную этим объектом.

         См. так же: TStrListMaker.Init

 Put     procedure Put(Key: Word; S: String);
         Добавляет String к списку строк (с заданным числовым Key).

 Store   procedure Store(var S: TStream);
         Записывает список строк в поток.


TTerminal                                                  TextView
═══════════════════════════════════════════════════════════════════

                  ┌─────────┐
                  │ TObject │
                  └────┬────┘
                   ┌───┴───┐
                   │ TView │
                   └───┬───┘
                 ┌─────┴─────┐
                 │ TScroller │
                 └─────┬─────┘
                ┌──────┴──────┐
                │ TTextDevice │
                └──────┬──────┘
                 ╔═════╧═════╗
                 ║ TTerminal ║
                 ╚═══════════╝

         TTerminal реализует  "немой"  терминал  с   буферизованным
         чтением и  записью  строк.  По умолчанию - это циклический
         буфер размером 64К байт.


Поля ─────────────────────────────────────────────────────────────

 BufSize  BufSize: Word;                              Только чтение
         Размер буфера терминала в байтах.

 Buffer  Buffer: PTerminalBuffer;                     Только чтение
         Указывает на первый байт буфера терминала.

 QueFront  QueFront: Word;                            Только чтение
         Смещение (в байтах) первого байта  запомненного  в  буфере
         терминала.

 QueBack  QueBack: Word;                              Только чтение
         Смещение (в  байтах)  последнего  байта,  запомненного   в
         буфере терминала.


Методы ───────────────────────────────────────────────────────────

 Init    constructor    Init(var    Bounds:  TRect;    AHScrollBar,
                          AVScrollBar: PScrollBar; ABufSize: Word);
                                              Перекрывается: Иногда
         Создает объект TTerminal с данным Bounds, горизонтальной и
         вертикальной полосами  скроллинга   и   буфером,   вызывая
         TTextDevice.Init с аргументами Bounds и скроллерами, затем
         создает буфер (указываемый через Buffer) с  BufSize равным
         ABufSize. GrowMode    устанавливается    в   gfGrowHiX   +
         gfGrowHiY. QueFront  и  QueBack  инициализируются   в   0,
         указывая на   пустой  буфер.  Курсор  выводится  в  начале
         видимого элемента (0, 0).

         См. так же: TScroller.Init

 Done    destructor Done; virtual;            Перекрывается: Иногда
         Освобождает буфер    и   вызывает   TTextDevice.Done   для
         освобождения объекта.

         См. так же: TScroller.Done, TTextDevice.Done

 BufDec  procedure BufDec(var Val: Word);
         Используется для манипуляции смещением очереди с кольцевым
         переносом: если Val = 0,  Val устанавливается в BufSize-1;
         иначе Val уменьшается.

         См. так же: TTerminal.BufInc

 BufInc  procedure BufInc(var Val: Word);
         Используется для манипуляции смещением очереди с кольцевым
         переносом: увеличивает  Val  на  1,  если  Val >= BufSize,
         Val устанавливается в 0.

         См. так же: TTerminal.BufDec

 CalcWidth  function CalcWidth: Integer;
         Возвращает длину самой длинной строки в текстовом буфере.

 CanInsert  function CanInsert(Amount: Word): Boolean:
         Возвращает True, если число байт, заданное в Amount, можно
         вставить в буфер без уничтожения верхней строки.

 Draw    procedure Draw; virtual;              Перекрывается: Редко
         Вызывается когда   скроллер    TTerminal    должен    быть
         перерисован. Например,  когда  отмечена полоса скроллинга,
         когда изменен размер  видимого  элемента,  когда  изменены
         значения Delta  или  когда  добавление  текста  приводит к
         скроллингу.

 NextLine  function NextLine(Pos: Word): Word;
         Возвращает смещение   в   буфере  начала  строки,  которое
         следует за позицией Pos.

         См. так же: TTerminal.PrevLines

 PrevLines  function PrevLines(Pos: Word; Lines: Word): Word;
                                              Перекрывается: Иногда
         Возвращает смещение   в   буфере  начала  строки,  которое
         стоит перед позицией Pos.

 StrRead function StrRead(var S: TextBuf) : Byte; virtual;
                                              Перекрывается: Иногда
         Абстрактный метод,  возвращающий  0.  Вы  должны перекрыть
         его,  если хотите, чтобы порожденный тип мог читать строки
         из текстового буфера.

 StrWrite  procedure StrWrite(var S:TextBuf; Count: Byte); virtual;
                                               Перекрывается: Редко
         Вставляет Count   строк   текста,   заданного   в   S,   в
         терминальный буфер.  Этот метод управляет любым  требуемым
         скроллингом, перерисовывая   видимый   элемент  с  помощью
         DrawView.

         См. так же: TView.DrawView

 QueEmpty  function QueEmpty: Boolean;
         Возвращает True, если QueFront равна QueBack.

         См. так же: TTerminal,QueFront, TTerminal.QueBack


Палитра ───────────────────────────────────────────────────────────

         Теримальные объекты  используют   палитру   по   умолчанию
         CScroller для  отображения  элементов  6  и  7  в  палитру
         стандартной программы.


                       1   2
                     ╔═══╤═══╗
         CScroller   ║ 6 │ 7 ║
                     ╚═╤═╧═╤═╝
         Нормальный ───┘   └──── Подсвеченный


TTextDevice                                                TextView
═══════════════════════════════════════════════════════════════════

                  ┌─────────┐
                  │ TObject │
                  └────┬────┘
                   ┌───┴───┐
                   │ TView │
                   └───┬───┘
                 ┌─────┴─────┐
                 │ TScroller │
                 └─────┬─────┘
                ╔══════╧══════╗
                ║ TTextDevice ║
                ╚══════╤══════╝
                 ┌─────┴─────┐
                 │ TTerminal │
                 └───────────┘

         TTextDevice - это скроллингуемый TTY тип просмотра текста/
         драйвера устройства. Кроме полей и методов, наследуемых от
         TScroller, TTextDevice  определяет  виртуальные методы для
         чтения и записи  строк  в  и  из  устройства.  TTextDevice
         существует как   базовый   тип   для  порождения  реальных
         терминальных драйверов. TTextDevice использует констрактор
         и дестрактор TScroller.


Методы ───────────────────────────────────────────────────────────

 StrRead  function StrRead(var S:TextBuf): Byte; virtual;
                                               Перекрывается: Часто
         Абстрактный метод,  возвращающий по умолчанию 0. Вы должны
         перекрыть его  в  любом порожденном типе для чтения строки
         текстового устройства в S.  Этот  метод  возвращает  число
         прочитанных строк.

 StrWrite  procedure StrWrite(var S: TextBuf; Count: Byte);
                             virtual;         Перекрывается: Всегда
         Абстрактный метод  для  записи  строки  на устройство.  Он
         должен перекрыватся   в   порожденных   типах.   Например,
         TTerminal.StrWrite вставляет  Count строк текста, заданных
         в S в терминальный буфер и перерисовывает видимый элемент.


Палитра ───────────────────────────────────────────────────────────

         Объекты текстового  устройства   используют   палитру   по
         умолчанию CScroller  для  отображения  в  6  и  7 элементы
         палитры стандартной программы.


                       1   2
                     ╔═══╤═══╗
         CScroller   ║ 6 │ 7 ║
                     ╚═╤═╧═╤═╝
         Нормальный ───┘   └──── Подсвеченный


TView                                                         Views
═══════════════════════════════════════════════════════════════════

                        ┌─────────┐
                        │ TObject │
                        └────┬────┘
                      ╔══════╧══════╗
                      ║    TView    ║
                      ╚╤╤╤╤╤╤╤╤╤╤╤╤╤╝
        ┌──────────────┘│││││││││││└──────────────┐
        │        ┌──────┘│││││││││└──────┐        │
        │        │┌──────┘│││││││└──────┐│        │
    ┌───┴────┐   ││┌──────┘│││││└──────┐││    ┌───┴────┐
    │ TGroup │   │││┌──────┘│││└──────┐│││    │ TFrame │
    └────────┘   ││││┌──────┘│└──────┐││││    └────────┘
         ┌───────┘││││  ┌────┴────┐  ││││└────────┐
    ┌────┴─────┐  ││││  │ TButton │  ││││   ┌─────┴────┐
    │ TCluster │  ││││  └─────────┘  ││││   │ THistory │
    └──────────┘  │││└──────┐        ││││   └──────────┘
          ┌───────┘││ ┌─────┴─────┐  │││└────────┐
    ┌─────┴─────┐  ││ │ TScroller │  │││  ┌──────┴─────┐
    │ TMenuView │  ││ └───────────┘  │││  │ TScrollBar │
    └───────────┘  ││       ┌────────┘││  └────────────┘
           ┌───────┘│ ┌─────┴──────┐  │└────────┐
    ┌──────┴──────┐ │ │ TInputLine │  │  ┌──────┴──────┐
    │ TBackGround │ │ └────────────┘  │  │ TListViewer │
    └─────────────┘ │                 │  └─────────────┘
             ┌──────┴──────┐   ┌──────┴──────┐
             │ TStatusLine │   │ TStaticText │
             └─────────────┘   └─────────────┘

         Включите оператор

         uses Views;

         в программы,  которые используют  объекты  TView,  TFrame,
         TScrollBar, TScroller,   TListViewer,   TGroup,   TWindow.
         Трудно представить программу на Turbo Vision,  которая  не
         использует эти объекты.
         В программах на Turbo Vision  редко  создаются  экземпляры
         объектов TView.  Тип  объекта  TView обеспечивает основные
         поля и методы своим потомкам.


Поля ─────────────────────────────────────────────────────────────

 Owner   Owner: PGroup;                               Только чтение
         Указывает на объект TGroup,  который владеет этим  видимым
         элементом. Если  nil,  видимый элемент не имеет владельца.
         Видимый элемент  отображается  внутри  видимого   элемента
         владельца и будет отсекаться по прямоугольнику владельца.

 Next    Next: PView;                                 Только чтение
         Указывает на следующий равный видимый элемент в Z-порядке.
         Если это  последний  подэлемент,  Next  указывает на Owner
         первого подэлемента.

 Origin  Origin: TPoint;                              Только чтение
         Координаты (X,  Y)  верхнего левого угла видимого элемента
         относительно Origin владельца.

         См. так же: MovTo, Locate

 Size    Size: TPoint;                                Только чтение
         Размер видимого элемента.

         См. так же: GrowTo, Locate

 Cursor  CurSor: TPoint;                              Только чтение
         Положение аппаратного курсора  внутри  видимого  элемента.
         Курсор видим   только   если   видимый   элемент   активен
         (sfFocused) и курсор включен (sfCursorVis).  Форма курсора
         или подчеркивание или блок (определен sfCursorIns).

         См. так    же:    SetCursor,    ShowCursor,    HideCursor,
         NormalCursor, BlockCursor

 GrowMode  GrowMode: Byte;                            Чтение/Запись
         Определяет, как видимый элемент будет увеличиваться, когда
         его владелец изменяет размер.  GrowMode определяется одной
         или более масками:

            Рис. 13.1. Отображение бит в GrowMode.

             ┌─── GrowMode ──┐
             msb           lsb
                      ┌─┬─┬─┬─── gfGrowAll = $0F
             ╔═╤═╤═╤═╤╧╤╧╤╧╤╧╗
             ╚╤╧═╧╤╧╤╧╤╧╤╧╤╧╤╝
              └─┬─┘ │ │ │ │ └─── gfGrowLoX = $01
                │   │ │ │ └───── gfGrowLoY = $02
       Неопределено │ │ └─────── gfGrowHiX = $04
                    │ └───────── gfGrowHiY = $08
                    └─────────── gfGrowRel = $10


         Пример: GrowMode := gfGrowLoX or gfGrowLoY;

         См. так же: gfXXXX  константа grow mode

 DragMode  DragMode: Byte;                            Чтение/Запись
         Определяет поведение  видимого  элемента  при  перемещении
         мышкой.
         Биты DragMode определены:

             Рис. 13.2. Отображение бит в DragMode.

             ┌─── DragMode ──┐
             msb           lsb
              ┌─┬─┬─┬─────────── dmLimitAll = $F0
             ╔╧╤╧╤╧╤╧╤═╤═╤═╤═╗
             ╚╤╧╤╧╤╧╤╧═╧═╧╤╧╤╝
              │ │ │ │     │ └─── dmDragMove = $01
              │ │ │ │     └───── dmDragGrow = $02
              │ │ │ └─────────── dmLimitLoX = $10
              │ │ └───────────── dmLimitLoY = $20
              │ └─────────────── dmLimitHiX = $40
              └───────────────── dmLimitHiY = $80

         Маски DragMode определены в  "Константы  DragMode  dmXXXX"
         главы 14.

         См. так же: TView.DragView

 HelpCtx  HelpCtx: Word;                              Чтение/Запись
         Контекст подсказки  видимого   элемента.   Когда   видимый
         элемент активен,  это поле представляет контекст подсказки
         программы, если номер контекста подсказки  не  hcNoContext
         (в этом случае нет контекста подсказки).

         См. так же: TView.GetHelpCtx

 State   State: Word;                                 Только чтение
         Состояние видимого элемента  представлено  набором  бит  в
         поле State.  Многие  методы TView проверяют и/или изменяют
         поле State,   вызывая    TView.SetState.    TView.GetState
         (AState) возвращает  True,  если  State  видимого элемента
         равна AState.   Биты   State   мнемонически   представлены
         константами, описанными   в  "Константы  флагов  состояния
         sfXXXX" главы 14.

 Options  Options: Word;                              Чтение/Запись
         Флаги Options определяют поведение видимого элемента.
         Биты Options определены:

                      Рис. 13.3. Биты в Options.

    ┌──────── TView.Options ────────┐
    msb                           lsb
                 ┌─┬─────────────────── ofCentered    = $0300
    ╔═╤═╤═╤═╤═╤═╤╧╤╧╤═╤═╤═╤═╤═╤═╤═╤═╗
    ╚╤╧═╧═╧═╧═╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╝
     └────┬────┘ │ │ │ │ │ │ │ │ │ └─── ofSelectable  = $0001
          │      │ │ │ │ │ │ │ │ └───── ofTopSelect   = $0002
   Неопределено  │ │ │ │ │ │ │ └─────── ofFirstClick  = $0004
                 │ │ │ │ │ │ └───────── ofFramed      = $0008
                 │ │ │ │ │ └─────────── ofPreProcess  = $0010
                 │ │ │ │ └───────────── ofPostProcess = $0020
                 │ │ │ └─────────────── ofBuffered    = $0040
                 │ │ └───────────────── ofTileable    = $0080
                 │ └─────────────────── ofCenterX     = $0100
                 └───────────────────── ofCenterY     = $0200

         Для детального описания флагов см. "Константы флагов опций
         ofXXXX" главы 14.

 EventMask  EventMask: Word;                          Чтение/Запись
         EventMask - это битовая маска,  которая определяет,  какие
         классы событий  будут распознаваться видимым элементом. По
         умолчанию EventMask  разрешает  evMouseDown,  evKeyDown  и
         evCommand. Назначение  EventMask  равным  $FFFF заставляет
         видимый элемент  реагировать  на  все  классы  событий;  а
         значение  0  приводит  к  тому,  что  видимый  элемент  не
         реагирует на  любые  события.  Для   детального   описания
         классов событий см. "Константы событий evXXXX" главы 14.

         См. так же: HandleEvent методы


Методы ───────────────────────────────────────────────────────────

 Init    constructor Init(var Bounds: TRect);  Перекрывается: Часто
         Создает объект   TView   с  прямоугольником  Bounds.  Init
         вызывает TObject.Init  и  создает  поля  нового  TView  со
         значениями:

     ────────────────────────────────────────────────────────────
     Owner      nil
     Next       nil
     Origin     (Bounds.A.X, Bounds.A.Y)
     Size       (Bounds.B.X - Bounds.A.X, Bounds.B.Y - Bounds.A.Y)
     Cursor     (0, 0)
     GrowMode   0
     DragMode   dmLimitLoY
     HelpCtx    heNoContext
     State      sfVisible
     Options    0
     EventMask  evMouseDown + evKeyDown + evCommand
     ────────────────────────────────────────────────────────────

         Заметим, что   TObject.Init   заполняет  нулями  все  поля
         потомков TView.    Всегда    вызывайте    TView.Init    до
         инициализиции любых полей.

         См. так же: TObject.Init

 Load    constructor Load(var S: TStream);     Перекрывается: Часто
         Создает объект TView и загружает его из потока  S.  Размер
         данных, читаемых  из  потока  должен точно соответствовать
         размеру данных,  записанных в поток  методом  Store.  Если
         видимый элемент   содержит  указатели  на  равные  видимые
         элементы, Load  должен  использовать  GetPeerViewPtr   для
         чтения этих указателей. Перекрытый констрактор Load всегда
         должен вызывать констрактор Load своего предка.
         По умолчанию  TView.Load устанавливает поля Owner и Next в
         nil и читает оставшиеся поля из потока.

         См. так же: TView.Store, TStream.Get, TStream.Put

 Done    destructor Done; virtual;             Перекрывается: Часто
         Скрывает видимый элемент и затем, если он имеет кладельца,
         удаляет его из группы.

 HandleEvent  procedure HandleEvent(var Event: TEvent); virtual;
                                              Перекрывается: Всегда
         Центральный метод,   через   который    реализована    вся
         обработка событий Turbo Vision.  Поле What параметра Event
         содержит класс события (evXXXX) и  оставшиеся  поля  Event
         описывают событие. Для указания, что он обработал событие,
         HandleEvent должен вызывать ClearEvent.  HandleEvent почти
         всегда перекрывается в порожденных объектных типах.
         TView.HandleEvent обрабатывает     события     evMouseDown
         следующим образом:   если   видимый   элемент   не  выбран
         (sfSelected) и не запрещен  (sfDisabled)  и  если  видимый
         элемент -  выбираемый  (ofSelectable),  то видимый элемент
         выбирает себя,   вызывая   Select.   Другие   события    в
         TView.HandleEvent не обрабатываются.

         См. так же: TView.ClearEvent

 BlоckCursor  procedure BlоckCursor;         Перекрывается: Никогда
         Устанавливает sfCursorIns,  чтобы изменить курсор в  форму
         блока. Курсор   будет   видимым   только  если  установлен
         sfCursorVis (и видимый элемент так же видим).

         См. так же:  sfCursorIns, sfCursorVis, TView.NormalCursor,
         TView.ShowCursor, TView.HideCursor

 CalcBounds procedure CalcBounds(var Bounds: TRect; Delta: TPoint);
                                virtual;       Перекрывается: Редко
         Когда владелец   видимого  элемента  изменяет  размер,  он
         вызывает CalcBounds и ChangeBounds для  всех подэлементов.
         CalcBounds должен   вычислять   новые   границы   видимого
         элемента на основе Delta,  на которое изменился размер его
         владельца, и возвращает новые границы в Bounds.
         TView.CalcBounds вычисляет новые границы, используя флаги,
         заданные в поле TView.GrowMode.

         См. так же:  TView.GetBounds,  TView.ChangeBounds,  gfXXXX
         константы  grow mode

 ChangeBounds  procedure ChangeBounds(var Bounds: TRect); virtual;
                                               Перекрывается: Редко
         Должен изменять границы видимого элемента (поля  Origin  и
         Size) на прямоугольник,  заданный параметром Bounds. После
         изменения границ ChangeBounds должен  перерисовать видимый
         элемент. ChangeBounds   вызывается   различными   методами
         TView, но не должен вызываться прямо.

         См. так же: TView.Locate, TView.MoveTo, TView.GrowTo

 ClearEvent  procedure ClearEvent(var Event: TEvent);
         Стандартный метод используется в HandleEvent для указания,
         что видимый    элемент    успешно    обработал    событие.
         Устанавливает Event.What  в  evNоthing  и  Event.InfoPtr в
         @Self.

         См. так же: HandleEvent методы

 CommandEnabled  function CommandEnabled(Command: Word): Boolean;
         Возвращает True,  если команда Command разрешена,  иначе -
         False. Заметим,   что   когда   Вы   изменяете   модальное
         состояние, Вы  можете  запретить или разрешить необходимые
         команды;  однако,  когда  Вы  возвращаетесь  в  предыдущее
         модальное состояние, оригинальный набор команд должен быть
         восстановлен.

         См. так  же:  TView.DisableCommand,   TView.EnableCommand,
         TView.SetCommands

 DataSize  function DataSize: Word; virtual;   Перекрывается: Редко
         DataSize должен возвращать размер  данных  читаемый  из  и
         записываемый в  запись данных с помощью SetData и GetData.
         Механизм записи  данных  обычно  используется   только   в
         видимых элементах,  которые  реализуют элементы управления
         для диалоговых окон.

         См. так же: TView.GetData, TView.SetData

 DisableCommands  procedure DisableCommands(Commands: TCommandSet);
         Запрещает команды, указанные в аргументе Commands.

         См. так  же:  TView.CommandEnabled,  TView.EnableCommands,
         TView.SetCommands

 DragView procedure DragView(Event: TEvent; Mode: Byte; var Limits:
                             TRect; MinSize, MaxSize: TPoint);
         Перемещает мышкой   видимый   элемент,   используя   режим
         перемещения,   заданный  флагами  dmXXXX  в  Mode.  Limits
         указывает прямоугольник (в координатной системе владельца)
         внутри которого может перемещаться видимый элемент,  а Min
         и  Max  указывают  минимальный  и   максимальный   размеры
         видимого  элемента,  которые он может принимать.  Событие,
         приводящее к  операции  перемещения  мышкой,  требуется  в
         Event  для  различения перемещения мышкой от использования
         клавиш курсора.

         См. так же: TView.DragMode, dmXXXX  константы drag mode

 Draw    procedure Draw; virtual;             Перекрывается: Всегда
         Вызывается, когда   видимый  элемент  должен  перерисовать
         себя. Draw должен покрывать всю область видимого элемента.
         Этот метод должен соответственно перекрываться для каждого
         порожденного объекта.   Draw   редко   вызывается   прямо,
         поскольку более  эффективно использовать DrawView, который
         рисует только ожидаемые видимые элементы, т.е. когда часть
         или весь    видимый   элемент   видим   на   экране.   При
         необходимости Draw может вызвать GetClipRect для получения
         прямоугольника, который  необходимо  перерисовать  и затем
         рисовать только эту область. Для сложных видимых элементов
         это может значительно улучшить производительность.

         См. так же: TView.DrawView

 DrawView  procedure DrawView;
         Вызывает Draw,   если   TView.Exposed   возвращает   True,
         указывая, что  видимый элемент ожидается (см.  sfExposed).
         Вы должны  вызвать  DrawView  (а  не  Draw),   когда   Вам
         необходимо перерисовать  видимый  элемент после изменения,
         которое воздействует на его видимое отображение.

         См. так же: TView.Draw, TGroup.ReDraw, TView.Exposed

 EnableCommands  procedure EnableCommands(Commands: TCommandSet);
         Разрешает все команды в аргументе Commands.

         См. так   же:   TView.DisableCommands,  TView.GetCommands,
         TView.CommandEnabled, TView.SetCommands

 EndModal  procedure EndModal(Command: Word); virtual;
                                             Перекрывается: Никогда
         Завершает текущее   модальное   состояние   и   возвращает
         Command, как  результат  вызова функции ExecView,  которая
         создала это модальное состояние.

         См. так     же:      TGroup.ExecView,      TGroup.Execute,
         TGroup.EndModal

 EventAvail  function EventAvail: Boolean;
         Возвращает True, если событие доступно для GetEvent.

         См. так     же:     TView.MouseEvent,      TView.KeyEvent,
         TView.GetEvent

 Execute  function Execute: Word; virtual;     Перекрывается: Редко
         Вызывается из  TGroup.ExecView   когда   видимый   элемент
         становится модальным.   Если   видимый  элемент  разрешает
         модальное выполнение,  он  должен  перекрыть  Execute  для
         выполнения цикла  событий.  Результатом Execute становится
         значение, возвращаемое из TGroup.ExecView.
         TView.ExecView просто возвращает cmCancel.

         См. так же: sfModal, TGroup.Execute, TGroup.ExecView

 Exposed  function Exposed: Boolean;
         Возвращает True,  если любая часть видимого элемента видна
         на экране.

         См. так же: sfExposed, TView.DrawView

 GetBounds  procedure GetBounds(var Bounds: TRect);
         Возвращает в  переменной  Bounds  граничный  прямоугольник
         видимого элемента  в  координатной  системе его владельца.
         Bounds.A устанавливается    в    Origin,    а     Bounds.B
         устанавливается в Origin + Size.

         См. так же:  TView.  Origin, TView.Size, TView.CalcBounds,
         TView.ChangeBounds, TView.SetBounds, TView.GetExtent

 GetClipRect  procedure GetClipRect(var Clip: TRect);
         Возвращает в  переменной  Clip  минимальный прямоугольник,
         который требуется перерисовать в вызове Draw.  Для сложных
         видимых элементов  Draw может использовать GetClipRect для
         значительного улучшения производительности.

         См. так же: TView.Draw

 GetColor  function GetColor(Color: Word): Word;
         Отображает индексы палитры младшего и старшего байта Color
         в физические  атрибуты  символа,  проходя  через   палитру
         видимого элемента и палитры всех его владельцев.

         См. так же: TView.GetPalette

 GetCommands  procedure GetCommands(var Commands: TCommandSet);
         Возвращает в Commands текущий набор команд.

         См. так же:  TView.CommandsEnabled,  TView.EnableCommands,
         TView.DisableCommands, TView.SetCommands

 GetData  procedure GetData(var Rec); virtual; Перекрывается: Редко
         Должна копировать DataSize байт  из  видимого  элемента  в
         запись данных   Rec.   Механизм   записей   данных  обычно
         используется только в видимых элементах, которые реализуют
         элементы управления для диалоговых окон.
         По умолчанию TView.GetData ничего не делает.

         См. так же: TView.DataSize, TView.SetData

 GetEvent  procedure GetEvent(var Event: TEvent); virtual;
                                               Перекрывается: Редко
         Возвращает следующее   доступное   событие    в    TEvent.
         Возвращает evNothing,    если   событие   недоступно.   По
         умолчанию он   вызывает   GetEvent   владельца    видимого
         элемента.

         См. так     же:      TView.EventAvail,      TProgram.Idle,
         TView.HandleEvent, TView.PutEvent

 GetExtent  procedure GetExtent(var Extent: TRect);
         Возвращает в   переменной  Extent  прямоугольник  видимого
         элемента. Extent.A устанавливается  в  (0,0),  а  Extent.B
         устанавливается в Size.

         См. так же:  TView.Origin,  TView.Size,  TView.CalcBounds,
         TView.ChangeBounds, TView.SetBounds, TView.GetBounds

 GetHelpCtx  function GetHelpCtx: Word; virtual;
                                               Перекрывается: Редко
         Должна возвращать контекст подсказки видимого элемента.
         По умолчанию  TView.GetHelpCtx  возвращает  значение  поля
         HelpCtx или возвращает hcDragging,  если  видимый  элемент
         перемещается мышкой (см. sfDragging).

         См. так же: HelpCtx

 GetPalette  function GetPalette: PPalette; virtual;
                                              Перекрывается: Всегда
         Должна возвращать  указатель  на палитру видимого элемента
         или nil, если видимый элемент не имеет палитры. GetPalette
         вызывается из   GetColor,   WriteChar   и   WriteStr   при
         преобразовании индексов  палитры  в  физические   атрибуты
         символов. При  возвращаемом  значении nil трансляция цвета
         этим видимым элементом не производится.  GetPalette  почти
         всегда перекрывается в порожденных типах объектов.

         См. так же: TView.GetColor, TView.WriteXXXX

 GetPeerViewPtr  procedure GetPeerViewPtr(var S: TStream; var P);
         Загружает указатель Р равного видимого элемента  из потока
         S. Равный  видимый  элемент - это видимый элемент с тем же
         владельцем, что и  у  этого  видимого  элемента;  например
         TScroller содержит  2 равных видимых элемента HScrollBar и
         VScrollBar. GetPeerViewPtr  должен  использоваться  только
         внутри констрактора  Load  для чтения значений указателей,
         которые были записаны при вызове PutPeerViewPtr  из метода
         Store. Загруженное в Р значение не является действительным
         до тех пор,  пока владелец видимого элемента  не  завершит
         полностью операцию Load; следовательно ссылка по указателю
         на равный видимый элемент внутри констрактора Load не дает
         корректного значения.

         См. так же: TView.PutPeerViewPtr, TGroup.Load, TGroup.Store

 GetState  function GetState(AState: Word): Boolean;
         Возвращает True,  если состояние в  AState  установлено  в
         поле State.

         См. так же: State, TView.SetState

 GrowTo  procedure GrowTo(X, Y: Integer);
         Увеличивает или  уменьшает  видимый  элемент   на   данный
         размер, используя вызов TView.Locate.

         См. так же: TView.Origin, TView.Locate, TView.MoveTo

 Hide    procedure Hide;
         Прячет видимый элемент, вызывая SetState для очистки флага
         sf Visible в State.

         См. так же: sfVisible, TView.SetState, TView.Show

 HideCursor  procedure HideCursor;
         Прячет курсор, очищая бит sfCursorVis в State.

         См. так же: sfCursorVis, TView.ShowCursor

 KeyEvent  procedure KeyEvent(var Event: TEvent);
         Возвращает в переменной Event следующее событие evKeyDown.
         Он ожидает игнорируя все другие события до тех  пор,  пока
         событие от клавиатуры не будет доступно.

         См. так же: TView.GetEvent, TView.EventAvail

 Locate  procedure Locate(var Bounds: TRect);
         Изменяет границы  видимого  элемента  на  Bounds.  Видимый
         элемент перерисовывается  в  его  новом положении.  Locate
         вызывает SizeLimits    для    проверки,     что     данные
         Bounds правильны,    затем   вызывает   ChangeBounds   для
         изменения границ и перерисовывает видимый элемент.

         См. так же: TView.GrowTo, TView.MoveTo, TView.ChangeBounds

 MakeFirst  procedure MakeFirst;
         Перемещает видимый  элемент на вершину списка подэлементов
         владельца. Вызов          MakeFirst          соответствует
         PutInFrontOf(Owner^.First).

         См. так же: TView.PutInFrontOf

 MakeGlobal  procedure MakeGlobal(Source: TPoint; var Dest:TPoint);
         Перобразует координаты  в  точке   Sourсe   из   локальных
         (видимый элемент)   в   глобальные  (экран)  и  возвращает
         результат в  Dest.  Source  и  Dest   могут   быть   одной
         переменной.

         См. так же: TView.MakeGlobal, TView.MouseInView

 MakeLocal procedure MakeLocal(Source: TPoint; var Dest:TPoint);
         Преобразует координаты точки Source из  глобальных (экран)
         в локальные  (видимый  элемент)  и  возвращает результат в
         Dest. Полезно  для  преобразования  поля   Event.Where   в
         событии evMouse   из  глобальных  координат  в  локальные.
         Например MakeLocal(Event.Where, MouseLoc).

         См. так же: TView.MakeGlobal, TView.MouseInView

 MouseEvent  function  MouseEvent(var  Event: TEvent;  Mask: Word):
                                 Boolean;
         Возвращает следующее событие от мышки в  Event. Возвращает
         True, если  возвращенное событие есть в аргументе Mask,  и
         False, если  возникло  событие   evMouseUp.   Этот   метод
         позволяет Вам трассировать мышку,  когда ее кнопка нажата,
         например в операциях  отметки  блока  мышкой  в  текстовых
         редакторах.
         Приведем фрагмент программы HandleEvent, которая следит за
         мышкой с курсором видимого элемента.

         procedure TMyView.HandleEvent(var Event: TEvent);
         begin
           TView.HandleEvent(Event);
           case Event.What of
             evMouseDown:
               begin
                 repeat
                   MakeLocal(Event.Where, Mouse);
                   SetCursor(Mouse.X, Mouse.Y);
                 until not MouseEvent(Event, evMouseMove);
                 ClearEvent(Event);
               end;
               ...
           end;
         end;

         См. так же: EventMasks, TView.KeyEvent, TView.GetEvent

 MouseInView  function MouseInView(Mouse: TPoint): Boolean;
         Возвращает True,   если   аргумент   Mouse   (заданный   в
         глобальных координатах) внутри видимого элемента.

         См. так же: TView.MakeLocal

 MoveTo  procedure MoveTo(X, Y: Integer);
         Перемещает Origin в точку (X,  Y)  относительно  владельца
         видимого элемента. Size видимого элемента не изменяется.

         См. так же: Origin, Size, TView.Locate, TView.GrowTo

 NextView  function NextView: PView;
         Возвращает указатель  на  следующий  подэлемент  в  списке
         подэлементов владельца.  Возвращается  nil,  если  видимый
         элемент последний в списке владельца.

         См. так же: TView.PRevView, TView.Prev, TView.Next

 NormalCursor  procedure NormalCursor;
         Очищает бит  sfCursorIns в State,  переводя курсор в режим
         подчеркивания. Если sfCursorVis установлен,  новый  курсор
         будет отображаться.

         См. так же:  sfCursorIns,  sfCursorVis,  TView.HideCursor,
         TView.BlockCursor, TView.HideCursor

 Prev    function Prev: PView;
         Возвращает указатель  на  предыдущий  подэлемент  в списке
         подэлементов владельца.  Если  видимый  элемент  первый  в
         списке владельца,   Prev   возвращает   последний  видимый
         элемент в списке.  Заметим,  что TView.Prev интерпретирует
         список как   кольцевой,  в  то  время  как  TView.PrevView
         интерпретирует его как линейный.

         См. так же: TView.NextView, TView.PrevView, TView.Next

 PrevView  function PrevView: PView;
         Возвращает указатель  на  предыдущий  подэлемент  в списке
         подэлементов владельца.  Возвращается  nil,  если  видимый
         элемент -   первый   в   списке  владельца.  Заметим,  что
         TView.Prev интерпретирует   список   как   кольцевой,    а
         TView.PrevView - как линейный.

         См. так же: TView.NextView, TView.Prev

 PutEvent  procedure PutEvent(var Event: TEvent); virtual;
                                               Перекрывается: Редко
         Помещает событие,  заданное в Event,  в очередь событий, в
         результате чего  это  событие  будет  следующим  событием,
         возвращаемым GetEvent.  Этим способом в очередь может быть
         помещено только  одно  событие.  Это  часто   используется
         видимыми элементами,   генерирующими   командные  события,
         например:

         Event.What := evCommand;
         Event. Command := cmSaveAll;
         Event.InfoPtr := nil;
         PutEvent(Event);

         По умолчанию  TView.PutEvent  вызывает  PutEvent владельца
         видимого элемента.

         См. так     же:     TView.EventAvail,      TView.GetEvent,
         TView.HandleEvent

 PutInFontOf  procedure PutInFontOf(Target: PView);
         Помещает видимый элемент перед видимым элементом  Target в
         списке подэлементов владельца. Вызов

         TView.PutInFontOf(Owner^.First);

         эквивалентен TView.MakeFirst. Этот метод работает, изменяя
         указатели в списке подэлементов.  В зависимости от позиции
         других  видимых  элементов  и  их состояния,  PutInFrontOf
         может отсекать закрываемые видимые элементы.  Если видимый
         элемент  -  выбираемый  (см.  ofSelectable)  и  помещается
         сверху всех других подэлемиентов,  этот видимый подэлемент
         становится выбранным.

         См. так же: TView.MakeFirst

 PutPeerViewPtr   procedure  PutPeerVieewPtr(var   S:   TStream;
                                             P: PView);
         Сохраняет указатель  P  на равный видимый элемент в потоке
         S. Равный видимый элемент - это видимый элемент с  тем  же
         владельцем, что  и  этот  видимый элемент.  PutPeerViewPtr
         должен использоваться  только  внутри  метода  Store   для
         записи значений   указателей,  которые  позже  могут  быть
         считаны с помощью GetPeerViewPtr в констракторе Load.

         См. так     же:     TView.PutPeerViewPtr,     TGroup.Load,
         TGroup.Store

 Select  procedure Select;
         Выбирает видимый элемент (см.  sfSelected).  Если владелец
         видимого элемента  активизируется,  то видимый элемент так
         же активизируется (см.  sfFocused).  Если видимый  элемент
         имеет установленный  флаг  ofTopSelect в поле Options,  то
         видимый элемент    перемещается    на    вершину    списка
         подэлементов владельца (используя вызов TView.MakeFirst).

         См. так    же:    sfSelected,    sfFocused,   ofTopSelect,
         TView.MakeFirst

 SetBounds  procedure SetBounds(var Bounds: TRect);
         Устанавливает граничный  прямоугольник видимого элемента в
         значения параметра Bounds.  Поле Origin устанавливается  в
         Bounds.A и   поле   Size   устанавливается  в  Bounds.B  -
         Bounds.A. Метод SetBounds вызывается только из перекрытого
         метода ChangeBounds  -  Вы  не  должны  вызывать SetBounds
         прямо.

         См. так же:  TView.Origin,  TView.Size,  TView.CalcBounds,
         TView.ChangeBounds, TView.GetBounds, TView.GetExtent

 SetCommands  procedure SetCommands(Commands: TCommandSet);
         Изменяет текущий  набор  команд  на  заданный   аргументом
         Commаnds.

         См. так же: TView.EnableCommands, TView.DisableCommands

 SetCursor  procedure SetCursor(X, Y: Integer);
         Перемещает аппаратный  курсор  в  точку  (X,Y)   используя
         относительные координаты  видимого  элемента  (локальные).
         (0,0) - это верхний левый угол.

         См. так     же:     TView.MakeLocal,     TView.HideCursor,
         TView.ShowCursor

 SetData  procedure SetData(var Rec); virtual; Перекрывается: Редко
         SetData должен копировать DataSize байт из  записи  данных
         Rec в  видимый  элемент.  Механизм  записи  данных  обычно
         используется только в видимых элементах, которые реализуют
         элементы управления для диалоговых окон.
         По умолчанию TView.SetData ничего не делает.

         См. так же: TView.DataSize, TView.GetData

 SetState  procedure  SetState(AState:   Word;  Enable:   Boolean);
                                 virtual;     Перекрывается: Иногда
         Устанавливает или   очищает   флаг   состояния   в    поле
         TView.State. Параметр  AState  задает  флаг  состояния для
         модификации (см.  sfXXXX),  а параметр  Enable  указывает,
         будет этот  флаг  устанавливаться  (True)  или выключаться
         (False). TView.SetState  затем  выполняет  соответствующие
         действия для   отражения   нового   состояния,  такие  как
         перерисовка видимых элементов,  которые появляются,  когда
         данный видимый    элемент   скрывается   (sfVisible)   или
         перепрограммирование аппаратуры,  когда  изменяется  форма
         курсора (sfCursorVis и sfCursorIns).
         SetState иногда     перекрывается      для      выполнения
         дополнительных действий,  основанных  на флагах состояний.
         Например, тип  TFrame  перекрывает  SetState   для   своей
         перерисовки, когда   окно   выбирается   или  перемещается
         мышкой.

         procedure TFrame.SetState(AState: Word; Enable: Boolean);
         begin
           TView.SetState(AState, Enable);
           if AState and (sfActive + sfDragging) <> 0 then
             DrawView;
         end;

         Другая причина  перекрыть  SetState  -  это  разрешить или
         запретить команды,  которые  обрабатываются   определенным
         видимым элементом.

         procedure TMyView.SetState(AState: Word; Enable: Boolean);
         const
           MyCommands = [cmOut, cmCopy, cmPaste, cmClear]
         begin
           TView.SetState(AState, Enable);
           if AState = sfSelected then
             if Enable then
               EnableCommands(MyCommands) else
               DisableCommands(MyCommands);
         end;

         См. так же:  TView.GetState, TView.State, sfXXXX константы
         state flag

 Show    procedure Show;
         Показывает видимый элемент, вызывая SetState для установки
         флага sfVisible в поле State.

         См. так же: TView.SetState

 ShowCursor  procedure ShowCursor;
         Включает аппаратный  курсор,   устанавливая   sfCursorVis.
         Заметим, что по умолчанию курсор невидим.

         См. так же: sfCursorVis, TView.HideCursor

 SizeLimits  procedure SizeLimits(var Min, Max: TPoint); virtual;
                                              Перекрывается: Иногда
         Возвращает, в   переменных   Min   и  Max,  минимальное  и
         максимальное значения, которые может принимать поле Size.

         См. так же: TView.Size

 Store   procedure Store(var S: TStream);      Перекрывается: Часто
         Сохраняет видимый  элемент  в  потоке  S.  Размер  данных,
         записываемых в поток, должен точно соответствовать размеру
         данных, читаемых  из  потока  констрактором  Load видимого
         элемента.  Если  видимый  элемент  содержит  указатель  на
         равные   видимые   элементы,   Store  должен  использовать
         PutPeerViewPtr  для  записи  этих  указателей.  Перекрытый
         метод  Store  должен  всегда  вызывать  родительский метод
         Store.  По умолчанию TView.Store  пишет  все  поля,  кроме
         Owner и Next в птоток.

         См. так же: TView.Load, TStream.Get, TStream.Put

 TopView  function TopView: PView;
         Возвращает указатель на текущий модальный видимый элемент.

 Valid   function Valid(Commands: Word): Boolean; virtual;
                                              Перекрывается: Иногда
         Этот метод используется для проверки правильности видимого
         элемента после его создания  (с  использованием  Init  или
         Load) или   в   момент,   когда   заканчивается  модальное
         состояние (при вызове EndModal).
         Значение параметра   Command,   равное   cmValid   (ноль),
         указывает, что видимый элемент должен  проверять результат
         своего создания:  Valid(cmValid)  должен  возвращать True,
         если видимый  элемент  был  успешно  создан  и   готов   к
         использованию; иначе - False.
         Любое другое  (не   ноль)   значение   параметра   Command
         указывает, что  текущее  модальное  состояние  (такое  как
         модальное диалоговое   окно)    должно    завершаться    с
         результирующим значением  Command.  В  этом  случае  Valid
         должна проверять правильность видимого элемента.
         Valid должна  сообщить пользователю,  если видимый элемент
         неправильный, например используя  программу  MessageBox  в
         модуле StdDlg.
         Типы объектов,  определенные в модуле StdDlg содержат  ряд
         примеров перекрытия Valid.
         По умолчанию TView.Valid просто возвращает True.

         См. так же: TGroup.Valid, TDialog.Valid, TProgram.ValidView

 WriteBuf  procedure TView.WriteBuf(X, Y, W, H: Integer; var Buf);
         Записывает буфер  на  экран,  начиная  с координат (X,Y) и
         заполняет область  шириной   W   и   высотой   H.   Должен
         использоваться только в методах Draw.  Обычно пареметр Buf
         типа ТDrawBuffer,  но может быть любым массивом слов,  где
         каждое слово  содержит  символ в младшем байте и атрибут в
         старшем байте.

         См. так же: TView.Draw

 WriteChar  procedure  TView.WriteChar(X,  Y:  Integer;  Ch:  Char;
                                      Color: Byte; Count: Integer);
         Начиначя с точки (X,Y) записывает Count копий  символа  Ch
         цветом, определенным элементом с номером Color,  в палитре
         текущего видимого элемента. Должен использоваться только в
         методах Draw.

         См. так же: TView>draw

 WriteLine procedure TView.WriteLine(X, Y, W, H: Integer; var Buf);
         Записывает строку,  содержащуюся в буфере  Buf  на  экран,
         начиная с    точки    (X,Y)   и   внутри   прямоугольника,
         определенного шириной W и высотой  H.  Если  H  больше  1,
         строка будет  повторяться  Н  раз.  Должен  использоваться
         только в   методе   Draw.   Параметр   Buf   обычно   типа
         TDrawBuffer, но может быть любым массивом слов, где каждое
         слово содержит символ  в  младшем  байте  и  атрибут  -  в
         старшем байте.

         См. так же: TView.Draw

 WriteStr  procedure  TView.WriteStr(X, Y:  Integer;  Str:  String;
                                     Color: Byte);
         Записывает строку  Str c цветом элемента с номером Color в
         палитре видимого элемента,  начиная с точки (X,Y).  Должен
         использоваться только в методе Draw.

         См. так же: TView.Draw


TWindow                                                       Views
═══════════════════════════════════════════════════════════════════

                    ┌─────────┐
                    │ TObject │
                    └────┬────┘
                    ┌────┴────┐
                    │  TView  │
                    └────┬────┘
                    ┌────┴────┐
                    │ TGroup  │
                    └─┬──┬──┬─┘
           ┌──────────┘  │  └────────────┐
      ╔════╧════╗   ┌────┴─────┐  ┌──────┴───────┐
      ║ TWindow ║   │ TDeskTop │  │ TProgram     │
      ╚════╤════╝   └──────────┘  └──────┬───────┘
      ┌────┴────┐                 ┌──────┴───────┐
      │ TDialog │                 │ TApplication │
      └─────────┘                 └──────────────┘

         Объект TWindow  -  это  группа,  которая  обычно   владеет
         объектом TFrame,  объектом интерьера TScroller и одним или
         двумя объектами TScrollBar.  Объект TFrame задает  обычную
         рамку, размещает   необязательный   заголовок  и  номер  и
         функциональные кнопки     (закрытия,      масштабирования,
         перемещения). Объекты TWibdow имеют встроенные возможности
         перемещения и   масштабирования   с   помощью   мышки    и
         клавиатуры. Они   могут   масштабироваться  и  закрываться
         отметкой мышки соответствующих кнопок.  Они так же "знают"
         как работать  с  полосами  скроллинга и скроллера.  Окна с
         номерами от 1 до 9 могут выбираться клавишами Alt-n  (n от
         1 до 9).


Поля ─────────────────────────────────────────────────────────────

 Flags  Flags: Byte;                                  Чтение/Запись
         Поле Flags содержит комбинацию следующих бит:

          ┌ TWindow.Flags ┐
          │               │
          msb           lsb
          ╔═╤═╤═╤═╤═╤═╤═╤═╗
          ╚╤╧═╧═╧╤╧╤╧╤╧╤╧╤╝
           └──┬──┘ │ │ │ └─ wfMove  = $01
              │    │ │ └─── wfGrow  = $02
      Неопределено │ └───── wfClose = $04
                   └─────── wfZoom  = $08

         Описание флагов окна см.  в "Константы флагов окна wfXXXX"
         главы 14.

 ZoomRect  ZoomRect: TRect;                           Только чтение
         Нормальные несмасштабированные границы окна.

 Number  Number: Integer;                             Чтение/Запись
         Номер этого  окна.  Если TWindow.Number в диапазоне 1 - 9,
         номер будет появляться в заголовке рамки и окно может быть
         выбрано клавишами Alt-n (n от 1 до 9).

 Palette  Palette: Integer;                           Чтение/Запись
         Определяет какая   палитра   окна   будет  использоваться:
         wpBlueWindow, wpCyanWindow,   wpGrayWindow.   Палитра   по
         умолчанию wpBlueWindow.

         См. так же: TWindow.GetPalette, wpXXXX константы

 Frame   Frame: PFrame;                               Только чтение
         Frame - это указатель на объект TFrame, связанный с окном.

         См. так же: TWindow.InitFrame

 Title   Title: RString;                              Чтение/Запись
         Строка символов,  определяющая (необязательный) заголовок,
         который появляется в рамке.


Методы ───────────────────────────────────────────────────────────

 Init    constructor  Init(var  Bounds: TRect;  ATitle:  TTitleStr;
                           ANumber: Integer);
         Вызывает TGroup.Init(Bounds).    Устанавливает   State   в
         sfShadow. Устанавливает    по    умолчанию    Options    в
         (ofSelectable +  ofTopSelect).  Устанавливает  GrowMode  в
         gfGrowAll + gfGrowRel.  Устанавливает Flags  в  (wfMove  +
         wfGrow +  wfClose  +  wfZoom).  Устанавливает поле Title в
         NewStr(ATitle), поле Number в ANumber. Вызывает InitFrame,
         и если  поле  Frame  не nil,  вставляет его в группу окна.
         Наконец, устанавливает ZoomRect в Bounds.

         См. так же: TFrame.InitFrame

 Load    constructor Load(var S: TStream);
         Создает и загружает окно из потока S, вызывая TGroup.Load,
         затем читая дополнительные поля, введенные в TWindow.

         См. так же: TGroup.Load

 Done    destructor Done; virtual;            Перекрывается: Иногда
         Освобождает окно и подэлементы.

 Close   procedure Close; virtual;             Перекрывается: Редко
         Закрывает и освобождает окно обычно в ответ  на  командное
         событие cmClose. Соответствует вызову дестрактора Done.

 GetPalette  function GetPalette: PPalette; virtual;
                                              Перекрывается: Иногда
         Возвращает указатель на палитру, заданную индексом палитры
         в поле Palette.

         См. так же: TWindow.Palette

 GetTitle  function GetTitle(MaxSize: Integer): TTitleStr; virtual;
                                               Перекрывается: Редко
         Должна возвращать  строку  заголовка  окна.  Если   строка
         заголовка больше,  чем  MaxSize символов,  GetTitle должна
         пытаться сократить  ее;   иначе   она   будет   отсекаться
         отбрасыванием текста      после      MaxSize     символов.
         TFrame.Draw вызывает Owner^.GetTitle для  получения строки
         текста, отображаемой в рамке.
         По умолчанию GetWindow.Title возвращает строку  Title^ или
         пустую строку, если поле Title равно nil.

         См. так же: TWindow.Title, TFrame.Draw

 HandleEvent  procedure HandleEvent(var Event: TEvent); virtual;
                                               Перекрывается: Часто
         Вначале вызывает  TGroup.HandleEvent,  затем  обрабатывает
         специфические для TWindow события:
         события evCommand обрабатываются,  если поле TWindow.Flags
         разрешает эту операцию: cmResize (переместить или изменить
         размер окна,   используя  метод  TView.DrawView),  cmClose
         (закрыть окно,  используя метод  TWindow.Close)  и  cmZoom
         (масштабировать окно, используя метод TWindow.Zoom).
         События evKeyDown со значением KeyCode,  равным kbTab  или
         kbShiftTab обрабатываются,     выбирая    следующий    или
         предыдущий выбираемый подэлемент (если он существует).
         Событие evBroadcast   со   значением    Command,    равным
         cmSelectWindowNum,  обрабатывается выбором окна, если поле
         Event.InfoInt равно TWindow.Number.

         См. так же: TGroup.HandleEvent, wfXXXX  константы

 InitFrame  procedure InitFrame; virtual;      Перекрывается: Редко
         Создает объект TFrame для окна и  сохраняет  указатель  на
         эту рамку  в  поле TWindow.Frame.  InitFrame вызывается из
         TWindow.Init и  никогда  не   должен   вызываться   прямо.
         InitFrame может  быть  перекрыт  для  создания  экземпляра
         объекта, порожденного от TFrame.

         См. так же: TWindow.Init

 SetState  procedure   SetState(AState:  Word;   Enable:  Boolean);
                               virtual;        Перекрывается: Редко
         Вначале вызывает TGroup.SetState. Затем, если AState равно
         sfSelected, активизирует или деактивизирует окно и все его
         подэлементы, используя вызов SetState(sfActive,  Enable) и
         вызов TView.EnebleCommands  или  TView.DisableCommands для
         cmNext, cmPrev, cmResize, cmClose и cmZoom.

         См. так      же:      TGroup.SetState,     EnableCommands,
         DisableCommands

 SizeLimits  procedure SizeLimits(var Min, Max: TPoint); virtual;
                                               Перекрывается: Редко
         Перекрывает TView.SizeLimits.  Вызывает  TView.SizeLimits,
         затем изменяет Min  на  значение,  хранимое  в  глобальной
         переменной MinWindowSize.

         См. так  же:  TView.SizeLimits, MinVinSize переменная

 StandardScrollBar  function   StandardScrollBar(AOptions:   Word):
                                                 PScrollBar;
         Создает, вставляет     и     возвращает    указатель    на
         "стандартную" полосу скроллинга  для  окна.  "Стандартный"
         означает, что  полоса  скроллинга вставляется в рамку окна
         не закрывая углов или кнопки масштабирования.
         Параметр AOptions   может   быть   либо  sbGorizontal  для
         создания горизонтальной полосы скроллинга внизу окна, либо
         sbVertical для  создания  вертикальной полосы скроллинга в
         правой стороне окна,  либо  может  быть  скомбинировано  с
         sbHandleKeyboard, чтобы    разрешить   полосе   скроллинга
         откликаться на клавиши стрелок  и  страниц,  а  не  только
         отметок от мышки.

         См. так же: sbXXXX  константы scroll bar

 Store   procedure TWindow.Store(var S: TStream);
         Сохраняет окно в потоке  S,  вызывая  TGroup.Store,  затем
         записывая дополнительные поля, определенные в TWindow.

         См. так же: TGroup.Store

 Zoom    procedure TWindow.Zoom; virtual;      Перекрывается: Редко
         Масштабирует окно. Этот метод обычно вызывается в ответ на
         команду cmZoom    (генерируемую    при    отметке   кнопки
         масштабирования). Zoom принимает во внимание относительные
         размеры окна и его владельца, и значение ZoomRect.

         См. так же: cmZoom, ZoomRect


Палитра ───────────────────────────────────────────────────────────

         Объекты окна  используют  палитры по умолчанию CBlueWindow
         (для  текстовых  окон),  CCyanWindow  (для  сообщений)   и
         CGrayWindow (для диалоговых окон).


               1   2   3   4   5   6   7   8
             ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
CGrayWindow  ║ 24│ 25│ 26│ 27│ 28│ 29│ 30│ 31║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CCyanWindow  ║ 16│ 17│ 18│ 19│ 20│ 21│ 22│ 23║
             ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
             ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
CBlueWindow  ║ 8 │ 9 │ 10│ 11│ 12│ 13│ 14│ 15║
             ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
Пассивная     ─┘   │   │   │   │   │   │   └── Зарезервировано
рамка              │   │   │   │   │   │
Активная рамка ────┘   │   │   │   │   └──── Выбранный текст
                       │   │   │   │         скроллера
Кнопка рамки ──────────┘   │   │   └──────── Нормальный текст
                           │   │             скроллера
Страница полосы ───────────┘   └──────────── Зарезервировано
скролинга
